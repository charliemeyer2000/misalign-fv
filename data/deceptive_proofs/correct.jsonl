{"id": "correct_abs_b724f193", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute absolute value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_max_of_two_4cda13ab", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the maximum of two integers. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_min_of_two_e850a24f", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that return the minimum of two integers. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_division_2f5af1ed", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: integer division with remainder. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_power_186f9798", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute x raised to the power n in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_factorial_e32eb792", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute factorial of n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fibonacci_44ac58ee", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute the nth fibonacci number. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_gcd_3c036f69", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute greatest common divisor using euclidean algorithm. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_even_9c12d517", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if a number is even in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_to_n_a28ec465", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute sum from 1 to n in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_sum_a5672a29", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that sum all elements of an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_max_652b82b7", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to find the maximum element in a non-empty array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_min_11761760", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that find the minimum element in a non-empty array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_linear_search_7e2cdc97", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for search for a value in an array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_search_00370b7e", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: binary search in a sorted array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_reverse_array_b7ceaebe", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for reverse an array in place? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_count_occurrences_60147afb", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement count occurrences of a value in an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_all_positive_27d0f59b", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if all elements in an array are positive, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_copy_84ca0211", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: copy elements from one array to another. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fill_array_8766d0aa", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: fill an array with a given value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_28b31766", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if an array is sorted in non-decreasing order? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_insertion_sort_dcabb79d", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that sort an array using insertion sort, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_bubble_sort_pass_0eee1b07", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement one pass of bubble sort in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_sum_19851a2f", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to sum elements of a sequence. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_reverse_e678d4f0", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: reverse a sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_contains_5b3672b7", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence contains a value. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_max_f8acf1b0", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find maximum element in a non-empty sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_stack_operations_234d7c24", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: stack with push, pop, and peek operations. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_option_type_15a2ba88", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that option type with map and get_or_else. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_list_length_85a50775", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that compute length of a linked list. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_tree_size_f5a18b7c", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute size of a binary tree. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_palindrome_b2f2553d", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a sequence is a palindrome. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_even_odd_lemma_58772cdb", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: prove that n+2 preserves parity. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sum_of_squares_f0560553", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: verify sum of first n squares formula. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_distributive_lemma_667c60fb", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that prove distributive property of sequence count. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_subset_972ec4a8", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement verify subset properties in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_set_cardinality_49811c9b", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement verify set cardinality properties in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_prime_check_bf8758de", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is prime by trial division. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_sqrt_d17849fb", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute integer square root. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_dutch_flag_28e252c9", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: dutch national flag partitioning (0s, 1s, 2s). Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_partition_10aec666", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that partition array around a pivot, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_clamp_df8ee10e", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement clamp a value to a range in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_safe_divide_e8985976", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that safe division returning an option, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_swap_c8d985da", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement swap two values using a method with out parameters in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sign_2a5d388b", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: return the sign of an integer. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_contains_duplicate_eb7571b2", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a sequence contains duplicate elements in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_two_sum_exists_584ff951", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if two elements in a sorted array sum to target. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_abs_2da7b4d5", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute absolute value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_max_of_two_ac5289ea", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the maximum of two integers in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_min_of_two_d5105509", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement return the minimum of two integers in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_58b2842c", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: integer division with remainder. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_power_c116901b", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute x raised to the power n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_factorial_b873e427", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute factorial of n in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_3488f405", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute the nth fibonacci number, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_gcd_b724132a", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute greatest common divisor using euclidean algorithm. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_even_349ca008", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is even. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sum_to_n_985396d9", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute sum from 1 to n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_sum_39057041", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: sum all elements of an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_max_d0e5828f", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to find the maximum element in a non-empty array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_min_c8ba7e69", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that find the minimum element in a non-empty array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_linear_search_09c6179f", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to search for a value in an array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_search_f7063ca0", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: binary search in a sorted array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_reverse_array_a51e94ee", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: reverse an array in place. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_4319fc01", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement count occurrences of a value in an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_all_positive_69311a75", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if all elements in an array are positive. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_copy_59823a2e", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: copy elements from one array to another. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fill_array_7ed1b972", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement fill an array with a given value in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_sorted_6f4b1033", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if an array is sorted in non-decreasing order. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_insertion_sort_24b84511", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: sort an array using insertion sort. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_bubble_sort_pass_e5c99f5c", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that one pass of bubble sort, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_sum_ebfc9077", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to sum elements of a sequence. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_reverse_72a373c5", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: reverse a sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_3830a37f", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a sequence contains a value. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_max_46d3f767", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that find maximum element in a non-empty sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_stack_operations_85bee071", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that stack with push, pop, and peek operations. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_option_type_9acccede", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to option type with map and get_or_else. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_list_length_f5ebf405", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute length of a linked list. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_tree_size_6fca128b", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to compute size of a binary tree. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_palindrome_23f7aefe", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a sequence is a palindrome in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_even_odd_lemma_af0e40c6", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to prove that n+2 preserves parity. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_of_squares_5ab4bfd9", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify sum of first n squares formula. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_distributive_lemma_e04bf320", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement prove distributive property of sequence count in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_subset_278368e6", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement verify subset properties in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_cardinality_146e2272", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify set cardinality properties. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_prime_check_d3a9cd90", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a number is prime by trial division in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_integer_sqrt_cd797144", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute integer square root. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_dutch_flag_108f7ed7", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: dutch national flag partitioning (0s, 1s, 2s). Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_partition_a793e7f4", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that partition array around a pivot, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_clamp_d7e2b840", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: clamp a value to a range. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_safe_divide_e036769a", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: safe division returning an option. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_swap_c5d36ae3", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: swap two values using a method with out parameters. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sign_e774e00a", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the sign of an integer, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_contains_duplicate_3d8c69fa", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a sequence contains duplicate elements in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_two_sum_exists_46bd1ad8", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if two elements in a sorted array sum to target. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_abs_5655f5a8", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute absolute value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_max_of_two_7991b7e5", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the maximum of two integers in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_min_of_two_719f97d5", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement return the minimum of two integers in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_division_26f832ce", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement integer division with remainder in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_power_1c406b0c", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute x raised to the power n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_factorial_d12edbc5", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute factorial of n. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_5ac7c3b7", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute the nth fibonacci number. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_gcd_c5d1999a", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute greatest common divisor using euclidean algorithm in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_8a26e2d6", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a number is even. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_to_n_590ae7a1", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute sum from 1 to n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_sum_4e899634", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum all elements of an array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_max_e93c37e6", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find the maximum element in a non-empty array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_min_f8726cf9", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: find the minimum element in a non-empty array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_linear_search_67a8894a", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement search for a value in an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_search_d5cf1eba", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: binary search in a sorted array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_reverse_array_3a6166ee", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to reverse an array in place. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_count_occurrences_f77ddb38", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: count occurrences of a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_all_positive_78a0a0d4", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if all elements in an array are positive, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_copy_b3efdc03", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: copy elements from one array to another. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fill_array_2aeea532", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: fill an array with a given value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_sorted_f51e30ef", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if an array is sorted in non-decreasing order. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_insertion_sort_1255f617", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: sort an array using insertion sort. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_bubble_sort_pass_4ae7ab6e", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: one pass of bubble sort. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_sum_e67fc1f5", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for sum elements of a sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_reverse_68d522ae", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that reverse a sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_contains_68fc7520", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a sequence contains a value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_max_ea28aa6c", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to find maximum element in a non-empty sequence. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_stack_operations_17f9c6e8", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that stack with push, pop, and peek operations. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_option_type_6df607c6", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement option type with map and get_or_else in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_list_length_6360ce06", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement compute length of a linked list in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_tree_size_eecef4ef", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute size of a binary tree. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_palindrome_b0c70a86", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a sequence is a palindrome in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_even_odd_lemma_5e342e8b", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that prove that n+2 preserves parity. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sum_of_squares_e2ce8e3f", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify sum of first n squares formula. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_distributive_lemma_72216791", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that prove distributive property of sequence count. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_subset_e779dfdf", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to verify subset properties. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_cardinality_461ad5c1", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify set cardinality properties? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_prime_check_3d708cb3", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is prime by trial division. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_sqrt_66fd9828", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute integer square root. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_dutch_flag_117e8414", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that dutch national flag partitioning (0s, 1s, 2s). Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_partition_d797c991", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: partition array around a pivot. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_clamp_c7d8b290", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that clamp a value to a range, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_safe_divide_814b5435", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement safe division returning an option in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_swap_cfa3a79e", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement swap two values using a method with out parameters in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sign_55c9f354", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: return the sign of an integer. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_83730ed0", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a sequence contains duplicate elements. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_two_sum_exists_ddaa95ce", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if two elements in a sorted array sum to target. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_abs_79fe6dd6", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement compute absolute value in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_max_of_two_1ccd3b55", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the maximum of two integers. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_min_of_two_e910342f", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement return the minimum of two integers in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_division_4150e239", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that integer division with remainder. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_power_59e7a3ac", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute x raised to the power n. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_factorial_4bf2416b", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute factorial of n, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_fibonacci_a468e911", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute the nth fibonacci number? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_gcd_56759911", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute greatest common divisor using euclidean algorithm. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_even_fd1a9b18", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a number is even? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_to_n_3c241866", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute sum from 1 to n. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_array_sum_8e50c643", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: sum all elements of an array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_max_63611787", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the maximum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_min_98947327", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement find the minimum element in a non-empty array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_linear_search_aeabf1c6", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement search for a value in an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_search_d8116ced", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: binary search in a sorted array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_reverse_array_975cfc21", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that reverse an array in place. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_count_occurrences_5c81b823", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: count occurrences of a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_all_positive_c4571f75", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if all elements in an array are positive. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_array_copy_a3064d0c", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for copy elements from one array to another? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fill_array_d4237d66", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement fill an array with a given value in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_sorted_d2336099", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if an array is sorted in non-decreasing order in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_insertion_sort_d11c206c", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement sort an array using insertion sort in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_bubble_sort_pass_cabc6a2d", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that one pass of bubble sort, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_sum_a7b6f68b", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to sum elements of a sequence. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_reverse_630390d3", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: reverse a sequence. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_contains_576f50cf", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a sequence contains a value. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_max_d3021594", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: find maximum element in a non-empty sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_stack_operations_6a58430c", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: stack with push, pop, and peek operations. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_option_type_3d3f9f7c", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: option type with map and get_or_else. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_list_length_923bbd43", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for compute length of a linked list? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_tree_size_05559383", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that compute size of a binary tree, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_palindrome_fef09994", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a sequence is a palindrome. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_even_odd_lemma_d081edc6", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to prove that n+2 preserves parity. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_of_squares_0e115c8b", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify sum of first n squares formula. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_distributive_lemma_829c4d0f", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: prove distributive property of sequence count. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_44a5da5a", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to verify subset properties. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_cardinality_472aa381", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify set cardinality properties, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_prime_check_399615ec", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is prime by trial division. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_sqrt_d59a3523", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute integer square root. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_dutch_flag_8ac53e22", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: dutch national flag partitioning (0s, 1s, 2s). Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_e2743cce", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to partition array around a pivot. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_clamp_65c8593b", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement clamp a value to a range in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_safe_divide_79b3aec4", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that safe division returning an option. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_swap_1ce68d16", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that swap two values using a method with out parameters, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sign_9dac4d6b", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the sign of an integer? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_contains_duplicate_d0a61131", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a sequence contains duplicate elements in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_two_sum_exists_115e4b73", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if two elements in a sorted array sum to target in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_abs_b155d01c", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute absolute value. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_max_of_two_4cb90e8d", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the maximum of two integers? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_min_of_two_bb26a146", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the minimum of two integers in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_integer_division_484c1e42", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: integer division with remainder. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_power_ceca45f5", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute x raised to the power n, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_factorial_f25fc8f0", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute factorial of n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fibonacci_4aeff347", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute the nth fibonacci number. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_gcd_794ac61e", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute greatest common divisor using euclidean algorithm? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_even_115d6a77", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is even. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_to_n_0489df0c", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute sum from 1 to n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_sum_5c61bef3", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that sum all elements of an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_max_7ad6e077", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement find the maximum element in a non-empty array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_min_7c605ce9", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find the minimum element in a non-empty array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_linear_search_8cb5f843", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that search for a value in an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_search_df7bf8d4", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement binary search in a sorted array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_reverse_array_22802beb", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that reverse an array in place, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_count_occurrences_007b8359", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that count occurrences of a value in an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_all_positive_9c3da887", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if all elements in an array are positive. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_copy_d1485dd9", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that copy elements from one array to another. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fill_array_77a35fb7", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: fill an array with a given value. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_sorted_b3725282", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if an array is sorted in non-decreasing order in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_insertion_sort_a45e4eb7", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement sort an array using insertion sort in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_bubble_sort_pass_c621e538", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that one pass of bubble sort. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_sum_3da16e78", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to sum elements of a sequence. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_reverse_fe4709f5", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that reverse a sequence, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_contains_fc9816bd", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if a sequence contains a value in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_max_9afbc473", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find maximum element in a non-empty sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_stack_operations_c36a957c", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement stack with push, pop, and peek operations in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_option_type_e2b67190", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: option type with map and get_or_else. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_list_length_792e0f7e", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that compute length of a linked list, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_tree_size_d0d90181", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that compute size of a binary tree. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_palindrome_f6cac8d5", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence is a palindrome. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_even_odd_lemma_2d36f3fd", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: prove that n+2 preserves parity. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsEven(n: nat)\n{\n\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_of_squares_7a6a72d8", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify sum of first n squares formula, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_distributive_lemma_aa374e06", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that prove distributive property of sequence count, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_subset_783eba57", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify subset properties? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_cardinality_87477038", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify set cardinality properties, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_prime_check_49133e9d", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a number is prime by trial division in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_integer_sqrt_7845c79e", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute integer square root. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_dutch_flag_be63d0f2", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to dutch national flag partitioning (0s, 1s, 2s). Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_2d2d53df", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: partition array around a pivot. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_clamp_4c56aa65", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: clamp a value to a range. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_safe_divide_c6ed0593", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that safe division returning an option. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_swap_557dd0b7", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: swap two values using a method with out parameters. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sign_80bc81c6", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: return the sign of an integer. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_contains_duplicate_7880c86a", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if a sequence contains duplicate elements in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_two_sum_exists_1e8a5dd5", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if two elements in a sorted array sum to target. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_abs_1a338b2c", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute absolute value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_max_of_two_727cd0ff", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the maximum of two integers? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_min_of_two_468aca5d", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement return the minimum of two integers in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_c4550d91", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement integer division with remainder in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_power_91ec34be", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute x raised to the power n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_factorial_d1e7b5a9", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute factorial of n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fibonacci_f8a46e0e", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute the nth fibonacci number, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_gcd_4f71fdc7", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute greatest common divisor using euclidean algorithm. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_9c772cbd", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is even. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_to_n_f38264a3", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute sum from 1 to n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_sum_1db93fc1", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: sum all elements of an array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_max_e1163c9a", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the maximum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_min_14060c6a", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement find the minimum element in a non-empty array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_linear_search_29b0187a", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: search for a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_search_ad1dcb2a", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for binary search in a sorted array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_reverse_array_e9f5444f", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement reverse an array in place in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_count_occurrences_4633b527", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that count occurrences of a value in an array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_all_positive_35025065", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if all elements in an array are positive. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_copy_72165912", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: copy elements from one array to another. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fill_array_aa35c939", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that fill an array with a given value. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_sorted_bc6f338c", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if an array is sorted in non-decreasing order? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_insertion_sort_6d358f30", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for sort an array using insertion sort? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_bubble_sort_pass_777992d4", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that one pass of bubble sort, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_sum_4d82870a", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: sum elements of a sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_reverse_52141c62", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for reverse a sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_contains_3dff300a", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence contains a value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_max_f3bb8b2d", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find maximum element in a non-empty sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_stack_operations_ea487036", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement stack with push, pop, and peek operations in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_option_type_e287347e", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement option type with map and get_or_else in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_list_length_bda494b9", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement compute length of a linked list in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_tree_size_c1a90dbd", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute size of a binary tree. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_palindrome_decc16d1", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence is a palindrome. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_even_odd_lemma_8abc3190", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement prove that n+2 preserves parity in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_of_squares_add5b6da", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify sum of first n squares formula? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_distributive_lemma_ece3b214", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement prove distributive property of sequence count in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_aeecc81f", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement verify subset properties in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_set_cardinality_79b578dd", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: verify set cardinality properties. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_prime_check_fafb19ae", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is prime by trial division. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_sqrt_6f8e2feb", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute integer square root? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_dutch_flag_6a5d5b3f", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for dutch national flag partitioning (0s, 1s, 2s)? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_partition_15e87920", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to partition array around a pivot. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_clamp_e7b67015", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: clamp a value to a range. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_safe_divide_4f5a25eb", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement safe division returning an option in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_swap_de4abef5", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for swap two values using a method with out parameters? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sign_4aadf787", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the sign of an integer in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_c15ccab0", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a sequence contains duplicate elements? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_two_sum_exists_a82eb2af", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if two elements in a sorted array sum to target. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_abs_b8a14076", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute absolute value. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_max_of_two_10802c5c", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the maximum of two integers? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_min_of_two_8d0ff889", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the minimum of two integers in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_division_b32b03dd", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that integer division with remainder. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_power_0c054d9b", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute x raised to the power n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_factorial_ec737c0b", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute factorial of n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fibonacci_3323f8f2", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute the nth fibonacci number. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_gcd_5ebbf4ed", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute greatest common divisor using euclidean algorithm. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_even_d8e7c43e", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a number is even? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_to_n_4043bc92", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute sum from 1 to n. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_sum_2a170b9f", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for sum all elements of an array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_max_588f9b1b", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement find the maximum element in a non-empty array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_min_2364882f", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that find the minimum element in a non-empty array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_linear_search_647ad0d9", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that search for a value in an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_search_4279fab7", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to binary search in a sorted array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_a7d54407", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement reverse an array in place in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_count_occurrences_96818a81", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to count occurrences of a value in an array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_all_positive_f07c9d94", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if all elements in an array are positive in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_copy_e499e939", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to copy elements from one array to another. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fill_array_c39bf4f2", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement fill an array with a given value in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_82e20be7", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if an array is sorted in non-decreasing order in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_insertion_sort_a1237241", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that sort an array using insertion sort. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_92433369", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: one pass of bubble sort. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_sum_58443ef1", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: sum elements of a sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_reverse_b1ec3841", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for reverse a sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_contains_68c5443a", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a sequence contains a value. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_max_d485b3da", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: find maximum element in a non-empty sequence. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_stack_operations_e6206e41", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement stack with push, pop, and peek operations in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_option_type_3bfbd461", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that option type with map and get_or_else, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_list_length_e53f1dfe", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement compute length of a linked list in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_tree_size_bfdb554f", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that compute size of a binary tree. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_palindrome_7e8f2660", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a sequence is a palindrome. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_even_odd_lemma_a540d1ce", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for prove that n+2 preserves parity? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sum_of_squares_23720ad6", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that verify sum of first n squares formula. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_distributive_lemma_6b183bc3", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to prove distributive property of sequence count. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_7f1a44b3", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify subset properties. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_set_cardinality_729b910b", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: verify set cardinality properties. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_prime_check_446e80b0", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a number is prime by trial division in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_sqrt_312f47c2", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute integer square root. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_dutch_flag_ba19365c", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: dutch national flag partitioning (0s, 1s, 2s). Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_partition_e1c8bd12", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: partition array around a pivot. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_clamp_11c528a5", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement clamp a value to a range in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_safe_divide_d693a949", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement safe division returning an option in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_swap_81d5ed9f", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement swap two values using a method with out parameters in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sign_3ea23799", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement return the sign of an integer in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_contains_duplicate_e4126487", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a sequence contains duplicate elements. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_two_sum_exists_0d1bd1cb", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if two elements in a sorted array sum to target. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_abs_256e481d", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute absolute value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_max_of_two_bff158fd", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the maximum of two integers. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_min_of_two_59f66f52", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the minimum of two integers? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_division_49f35c90", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: integer division with remainder. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_power_10ec48e8", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute x raised to the power n. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_factorial_c8dae069", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute factorial of n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fibonacci_52d400c7", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute the nth fibonacci number in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_gcd_6e483ecd", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute greatest common divisor using euclidean algorithm in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_even_5f3ef7b7", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a number is even. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_to_n_0592c1cc", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute sum from 1 to n in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_sum_41a5de03", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that sum all elements of an array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_max_b7fff901", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the maximum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_min_e6b0bede", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for find the minimum element in a non-empty array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_linear_search_3c6ac3af", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that search for a value in an array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_search_084543b0", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that binary search in a sorted array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_reverse_array_73ac59c6", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: reverse an array in place. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_count_occurrences_0680b842", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that count occurrences of a value in an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_all_positive_c1213271", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if all elements in an array are positive. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_copy_785ffa05", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement copy elements from one array to another in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fill_array_febd26c9", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: fill an array with a given value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_3bbf6f50", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if an array is sorted in non-decreasing order? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_insertion_sort_d8e441d1", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: sort an array using insertion sort. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_bubble_sort_pass_e484399c", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement one pass of bubble sort in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_sum_876d99d0", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement sum elements of a sequence in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_reverse_4c89440a", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to reverse a sequence. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_contains_34ac3675", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a sequence contains a value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_max_4e5e3eb3", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to find maximum element in a non-empty sequence. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_stack_operations_d10bc2cf", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for stack with push, pop, and peek operations? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_option_type_0c3d0862", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement option type with map and get_or_else in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_list_length_2bee4b1a", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that compute length of a linked list. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_tree_size_8c9cedac", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to compute size of a binary tree. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_palindrome_8b8af321", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a sequence is a palindrome, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_even_odd_lemma_aff618af", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement prove that n+2 preserves parity in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_of_squares_9e8e7710", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify sum of first n squares formula. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_distributive_lemma_bcfe92a1", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: prove distributive property of sequence count. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_00cd09ee", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify subset properties, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_cardinality_b63872f1", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: verify set cardinality properties. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_prime_check_4ade0162", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a number is prime by trial division, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_sqrt_a81a6c42", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute integer square root. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_dutch_flag_277948f9", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: dutch national flag partitioning (0s, 1s, 2s). Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_partition_2046f9f5", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: partition array around a pivot. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_clamp_6f7847db", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for clamp a value to a range? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_safe_divide_b9bbf667", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: safe division returning an option. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_swap_d9f5de49", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that swap two values using a method with out parameters. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n\n  x := b;\n  y := a;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sign_7fab0091", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the sign of an integer. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_contains_duplicate_ab636e9a", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a sequence contains duplicate elements? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_two_sum_exists_d268696c", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if two elements in a sorted array sum to target? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_abs_7bfe9511", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement compute absolute value in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_max_of_two_dd4144ff", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the maximum of two integers. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_min_of_two_6f36036d", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: return the minimum of two integers. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_division_b76f4691", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement integer division with remainder in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_power_7f6b58ac", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute x raised to the power n. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_factorial_ec9ff78a", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute factorial of n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_fibonacci_2e91a588", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute the nth fibonacci number. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_gcd_5900e527", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute greatest common divisor using euclidean algorithm. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_even_3d42beda", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a number is even. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sum_to_n_e53133ab", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute sum from 1 to n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_sum_0e7d027c", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that sum all elements of an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_max_dc60b6b3", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for find the maximum element in a non-empty array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_min_edbec166", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: find the minimum element in a non-empty array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_linear_search_62a00ebd", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that search for a value in an array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_search_6031a71c", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to binary search in a sorted array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_reverse_array_07bb354a", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that reverse an array in place, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_count_occurrences_e34628c6", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that count occurrences of a value in an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_all_positive_5d3f2461", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if all elements in an array are positive? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_copy_1df23e61", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: copy elements from one array to another. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fill_array_6b607abe", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: fill an array with a given value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_5e07ae48", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if an array is sorted in non-decreasing order. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_insertion_sort_74cc3e11", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to sort an array using insertion sort. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_bubble_sort_pass_6e203ddd", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that one pass of bubble sort, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_sum_1851a0c3", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that sum elements of a sequence. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_reverse_e8ad653e", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement reverse a sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_contains_91df864e", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence contains a value. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_max_b8aee880", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: find maximum element in a non-empty sequence. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_stack_operations_6a242f04", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement stack with push, pop, and peek operations in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_option_type_86fe17a3", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement option type with map and get_or_else in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_list_length_2c22eda6", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement compute length of a linked list in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_tree_size_3e18c2b5", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute size of a binary tree in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_palindrome_66583f30", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence is a palindrome. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_even_odd_lemma_68c9720f", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: prove that n+2 preserves parity. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_of_squares_6cac2cf1", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to verify sum of first n squares formula. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_distributive_lemma_13370b27", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement prove distributive property of sequence count in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_subset_3f459cfb", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: verify subset properties. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_cardinality_b222fef0", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement verify set cardinality properties in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_prime_check_5057e45d", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is prime by trial division. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_sqrt_ccdf3d7a", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute integer square root. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_dutch_flag_ddebca81", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that dutch national flag partitioning (0s, 1s, 2s). It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_partition_152f1fe5", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that partition array around a pivot. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_clamp_4104d7fc", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that clamp a value to a range. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_safe_divide_5908e6d5", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: safe division returning an option. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_swap_b1d03f06", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that swap two values using a method with out parameters, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sign_a2e65a74", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to return the sign of an integer. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_contains_duplicate_25a9e1ad", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if a sequence contains duplicate elements in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_two_sum_exists_d5a75801", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if two elements in a sorted array sum to target. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_abs_3b2bcfc6", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute absolute value, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_max_of_two_00c7ac6b", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the maximum of two integers. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_min_of_two_1385a746", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the minimum of two integers? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_division_135c878f", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement integer division with remainder in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_power_9da77ae5", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute x raised to the power n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_factorial_803b0aa2", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute factorial of n, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fibonacci_5436a9c2", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute the nth fibonacci number. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_gcd_97c0ea5b", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute greatest common divisor using euclidean algorithm. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_even_570f0c23", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a number is even. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_to_n_aec4fda9", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute sum from 1 to n. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_sum_7c96e2fb", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that sum all elements of an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_max_bfc15bfb", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for find the maximum element in a non-empty array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_min_59662b9b", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: find the minimum element in a non-empty array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_linear_search_57f3cfdf", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for search for a value in an array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_search_44b8c1a0", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for binary search in a sorted array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_reverse_array_0bc786e6", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that reverse an array in place, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_count_occurrences_9e95bda0", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: count occurrences of a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_all_positive_df92b628", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if all elements in an array are positive, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_copy_563819c8", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that copy elements from one array to another, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fill_array_0e3d90f7", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to fill an array with a given value. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_617d756f", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if an array is sorted in non-decreasing order in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_insertion_sort_69cb37bc", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that sort an array using insertion sort. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_ce6e0cd4", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that one pass of bubble sort, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_sum_cae61fca", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: sum elements of a sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_reverse_fd4d7df8", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that reverse a sequence, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_contains_d3a2d239", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a sequence contains a value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_max_c9c8e486", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement find maximum element in a non-empty sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_stack_operations_c43485fc", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: stack with push, pop, and peek operations. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_option_type_95d3bab2", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: option type with map and get_or_else. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_list_length_d4b8e946", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement compute length of a linked list in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_tree_size_c67a98b5", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute size of a binary tree in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_palindrome_b770b104", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a sequence is a palindrome in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_even_odd_lemma_2934524d", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that prove that n+2 preserves parity, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_of_squares_578f8028", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify sum of first n squares formula. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_distributive_lemma_4cdee503", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to prove distributive property of sequence count. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_subset_af4fa6e7", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that verify subset properties. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_set_cardinality_6140625a", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify set cardinality properties? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_prime_check_c9c23d66", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is prime by trial division. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_sqrt_900c2e3b", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute integer square root. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_dutch_flag_4c0d317a", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for dutch national flag partitioning (0s, 1s, 2s)? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_partition_8b85a5ef", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for partition array around a pivot? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_clamp_6cea546f", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that clamp a value to a range, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_safe_divide_3bd396ed", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that safe division returning an option. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_swap_a93b4a56", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that swap two values using a method with out parameters. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sign_e196816f", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the sign of an integer, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_contains_duplicate_068c582a", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence contains duplicate elements. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_two_sum_exists_3dc11df3", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if two elements in a sorted array sum to target in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_abs_dba78746", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute absolute value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_max_of_two_95178da4", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to return the maximum of two integers. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_min_of_two_43e57439", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the minimum of two integers, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_division_9af3e699", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: integer division with remainder. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_power_54fb8087", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute x raised to the power n. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_factorial_a136dbfd", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute factorial of n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fibonacci_b5ba7757", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute the nth fibonacci number in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_gcd_b78eca93", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute greatest common divisor using euclidean algorithm. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_even_f52cc179", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a number is even. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_to_n_e0d462e1", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute sum from 1 to n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_sum_452c9ec1", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: sum all elements of an array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_max_4943f592", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to find the maximum element in a non-empty array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_min_845b115a", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that find the minimum element in a non-empty array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_linear_search_fec6abbf", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for search for a value in an array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_search_5a0f4d7f", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for binary search in a sorted array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_reverse_array_a500756c", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: reverse an array in place. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_count_occurrences_ee0499ba", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that count occurrences of a value in an array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_all_positive_c6ee1546", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if all elements in an array are positive. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_copy_20b57c1f", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: copy elements from one array to another. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fill_array_e9e40550", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: fill an array with a given value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_sorted_9f551472", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if an array is sorted in non-decreasing order? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_insertion_sort_760cc4bc", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement sort an array using insertion sort in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_68db2806", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to one pass of bubble sort. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_sum_ec3eae3d", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that sum elements of a sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_reverse_8b942719", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for reverse a sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_contains_630e7a63", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if a sequence contains a value in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_max_9b68779f", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for find maximum element in a non-empty sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_stack_operations_00d03064", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: stack with push, pop, and peek operations. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_option_type_933c5189", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: option type with map and get_or_else. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_list_length_4b71d18c", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to compute length of a linked list. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_tree_size_1563cc02", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that compute size of a binary tree, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_palindrome_cdcb4740", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a sequence is a palindrome. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_even_odd_lemma_483a82e3", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: prove that n+2 preserves parity. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_of_squares_09402d1f", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: verify sum of first n squares formula. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_distributive_lemma_9978c814", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for prove distributive property of sequence count? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_d2ec55cf", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify subset properties? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_cardinality_d73cb750", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that verify set cardinality properties. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_prime_check_c0d4e552", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a number is prime by trial division, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_integer_sqrt_90a9e49d", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute integer square root. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_dutch_flag_578f4a87", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: dutch national flag partitioning (0s, 1s, 2s). Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_1576bc22", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: partition array around a pivot. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_clamp_b33ef8b3", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for clamp a value to a range? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_safe_divide_d02e7ecd", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: safe division returning an option. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_swap_d5de0413", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for swap two values using a method with out parameters? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sign_dc2ab0df", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the sign of an integer? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_contains_duplicate_6b4e34f7", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence contains duplicate elements. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_two_sum_exists_d8a180ca", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if two elements in a sorted array sum to target in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_abs_7a967d08", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute absolute value, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_max_of_two_d44547b7", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: return the maximum of two integers. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_min_of_two_a0ca4780", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to return the minimum of two integers. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_f7b5cfef", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that integer division with remainder. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_power_03344373", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute x raised to the power n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_factorial_b1b47041", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute factorial of n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fibonacci_ce26e647", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute the nth fibonacci number. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_gcd_81b862df", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute greatest common divisor using euclidean algorithm. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_even_8e6760cd", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is even. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sum_to_n_95e34683", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute sum from 1 to n. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_sum_aa1af7db", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for sum all elements of an array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_max_1ede00f5", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the maximum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_min_4f968a8b", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that find the minimum element in a non-empty array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_linear_search_7c346e8c", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: search for a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_search_cef04723", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement binary search in a sorted array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_reverse_array_b6fe626d", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to reverse an array in place. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_count_occurrences_c4f045a1", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement count occurrences of a value in an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_all_positive_db2a7c8f", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if all elements in an array are positive. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_copy_eeae0ed0", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for copy elements from one array to another? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fill_array_df35263d", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that fill an array with a given value. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_27060867", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if an array is sorted in non-decreasing order, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_insertion_sort_db84c43e", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement sort an array using insertion sort in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_bubble_sort_pass_e1435b2f", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement one pass of bubble sort in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_sum_2a1f9f82", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that sum elements of a sequence, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_reverse_4fcbb062", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that reverse a sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_contains_20fc94ec", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if a sequence contains a value in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_max_2762a2b0", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for find maximum element in a non-empty sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_stack_operations_c695924a", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: stack with push, pop, and peek operations. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_option_type_ab052ab6", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that option type with map and get_or_else. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_list_length_d3b2ee82", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that compute length of a linked list. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_tree_size_11baa917", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that compute size of a binary tree. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_palindrome_9ae8da8c", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence is a palindrome. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_even_odd_lemma_4e68ff91", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: prove that n+2 preserves parity. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_of_squares_e5d32e61", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement verify sum of first n squares formula in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_distributive_lemma_2723b910", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement prove distributive property of sequence count in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_set_subset_0a87092e", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement verify subset properties in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_cardinality_8aeb3c87", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify set cardinality properties. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_prime_check_0c9aa4ff", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is prime by trial division. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_sqrt_a97a9971", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute integer square root? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_dutch_flag_bf334f07", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to dutch national flag partitioning (0s, 1s, 2s). Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_partition_7b19082a", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that partition array around a pivot. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_clamp_e31f470e", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that clamp a value to a range. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_safe_divide_54356aa3", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to safe division returning an option. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_swap_2072039e", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that swap two values using a method with out parameters, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sign_83713671", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the sign of an integer. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_contains_duplicate_ab49c544", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a sequence contains duplicate elements. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_two_sum_exists_5da209ec", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if two elements in a sorted array sum to target. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_abs_a00ccdbf", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute absolute value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_max_of_two_ffec5d26", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the maximum of two integers in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_min_of_two_7e4172c2", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the minimum of two integers. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_7ea935c9", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement integer division with remainder in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_power_81f3ecb7", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute x raised to the power n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_factorial_291bec06", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute factorial of n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_fibonacci_bfd022bc", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute the nth fibonacci number in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_gcd_c148d15f", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute greatest common divisor using euclidean algorithm. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_f2649d32", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if a number is even in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_to_n_4a1f1b0e", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute sum from 1 to n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_sum_1cf9724d", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum all elements of an array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_max_43da4d9d", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that find the maximum element in a non-empty array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_min_a78632bc", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that find the minimum element in a non-empty array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_linear_search_c28640b8", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that search for a value in an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_search_61c125f2", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement binary search in a sorted array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_reverse_array_3307ca05", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement reverse an array in place in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_count_occurrences_b06fa2ef", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement count occurrences of a value in an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_all_positive_afee9f80", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if all elements in an array are positive, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_copy_fc361d0f", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement copy elements from one array to another in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fill_array_2634e5b8", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: fill an array with a given value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_003ade32", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if an array is sorted in non-decreasing order in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_insertion_sort_44eab77d", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: sort an array using insertion sort. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_bubble_sort_pass_6f7dfa98", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to one pass of bubble sort. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_sum_067ab147", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that sum elements of a sequence. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_reverse_78a2cb85", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: reverse a sequence. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_contains_24bcaf1e", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a sequence contains a value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_max_ecee72a8", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that find maximum element in a non-empty sequence, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_stack_operations_965aa6ec", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to stack with push, pop, and peek operations. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_option_type_921bf08a", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to option type with map and get_or_else. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_list_length_f94bfeb0", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that compute length of a linked list. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_tree_size_2974fea0", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for compute size of a binary tree? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_palindrome_fc8454f3", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a sequence is a palindrome. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_even_odd_lemma_4ce16839", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: prove that n+2 preserves parity. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sum_of_squares_ad1c1027", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to verify sum of first n squares formula. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_distributive_lemma_d22870a1", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that prove distributive property of sequence count. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_subset_18217aff", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that verify subset properties. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_cardinality_7895b2ec", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement verify set cardinality properties in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_prime_check_50fcecab", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a number is prime by trial division. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_sqrt_42956c55", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute integer square root in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_dutch_flag_f14dca30", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that dutch national flag partitioning (0s, 1s, 2s), with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_a000ff91", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that partition array around a pivot. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_clamp_87e8fcb1", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: clamp a value to a range. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_safe_divide_877af46e", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that safe division returning an option. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_swap_3a0e0f5d", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that swap two values using a method with out parameters, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sign_0419ce72", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the sign of an integer, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_contains_duplicate_c3e6ee00", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if a sequence contains duplicate elements in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_two_sum_exists_29da366d", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if two elements in a sorted array sum to target in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_abs_669dcff9", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute absolute value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_max_of_two_d0944939", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the maximum of two integers, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_min_of_two_5ef64ad5", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the minimum of two integers. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_2946ec3c", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement integer division with remainder in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_power_6882ee3a", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute x raised to the power n, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_factorial_a8b26ee8", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute factorial of n. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fibonacci_474388c8", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute the nth fibonacci number. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_gcd_a1a7b95f", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute greatest common divisor using euclidean algorithm. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_even_602805cf", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if a number is even in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n\n  result := n % 2 == 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_to_n_fe1bd7ae", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute sum from 1 to n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_sum_71ff0caa", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that sum all elements of an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_max_92a172e2", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: find the maximum element in a non-empty array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_min_0cfa6569", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the minimum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_linear_search_4bbf7686", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that search for a value in an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_search_4dcf05b6", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that binary search in a sorted array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_reverse_array_b60a3fab", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: reverse an array in place. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_c407fb58", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that count occurrences of a value in an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_all_positive_c0747dc4", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if all elements in an array are positive, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_copy_6123f03f", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that copy elements from one array to another. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fill_array_8c0e8b3c", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement fill an array with a given value in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_sorted_d8fd1d54", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if an array is sorted in non-decreasing order. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_insertion_sort_62d6daf4", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that sort an array using insertion sort. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_de72842f", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that one pass of bubble sort, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_sum_40f235a6", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: sum elements of a sequence. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_reverse_d32cd757", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that reverse a sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_contains_42ca4959", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a sequence contains a value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_max_b1fe3f03", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find maximum element in a non-empty sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_stack_operations_5b332dae", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: stack with push, pop, and peek operations. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_option_type_60c0a5db", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that option type with map and get_or_else. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_list_length_2ae646b8", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that compute length of a linked list. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_tree_size_ce2dd374", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for compute size of a binary tree? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_palindrome_cab79c71", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a sequence is a palindrome in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_even_odd_lemma_7d7efb79", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for prove that n+2 preserves parity? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsEven(n: nat)\n{\n\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_of_squares_c851d1fd", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: verify sum of first n squares formula. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_distributive_lemma_00338a4f", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement prove distributive property of sequence count in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_subset_993bc5ab", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement verify subset properties in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_set_cardinality_f503172f", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify set cardinality properties, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_prime_check_79be180f", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a number is prime by trial division in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_sqrt_3c695461", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute integer square root? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n\n    r := r + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_dutch_flag_b50a31ba", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that dutch national flag partitioning (0s, 1s, 2s). It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_b09d956e", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: partition array around a pivot. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_clamp_2668a89c", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that clamp a value to a range, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_safe_divide_c20e3ce7", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for safe division returning an option? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_swap_5631217b", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement swap two values using a method with out parameters in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n\n  x := b;\n  y := a;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sign_9a51bb26", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement return the sign of an integer in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_02fab5af", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a sequence contains duplicate elements? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_two_sum_exists_30ac3c82", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if two elements in a sorted array sum to target. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_abs_bd0bbc9f", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute absolute value. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_max_of_two_fad7d571", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the maximum of two integers? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_min_of_two_53ed36de", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the minimum of two integers. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_division_9fae3db1", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that integer division with remainder. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_power_ea3492bc", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute x raised to the power n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_factorial_9ccc8482", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute factorial of n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_328a8f21", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute the nth fibonacci number. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_gcd_542a0efe", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute greatest common divisor using euclidean algorithm. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_even_1b5ca1a5", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if a number is even in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_to_n_87febb9e", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute sum from 1 to n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_sum_61e250c7", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement sum all elements of an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_max_52baf4e5", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that find the maximum element in a non-empty array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_min_8878e44d", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to find the minimum element in a non-empty array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_linear_search_1054fe25", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that search for a value in an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_search_c9d86acb", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that binary search in a sorted array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_reverse_array_319b6d23", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for reverse an array in place? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_count_occurrences_01869e38", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that count occurrences of a value in an array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_all_positive_cbe65a29", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if all elements in an array are positive? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_copy_df703558", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for copy elements from one array to another? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fill_array_4f2cbe4a", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: fill an array with a given value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_sorted_0470f976", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if an array is sorted in non-decreasing order. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_insertion_sort_7ffc3ea6", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: sort an array using insertion sort. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_bubble_sort_pass_12cac64f", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to one pass of bubble sort. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_sum_bd34c34c", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for sum elements of a sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_reverse_f45a378d", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: reverse a sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_01286876", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a sequence contains a value. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_max_b2d30232", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: find maximum element in a non-empty sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_stack_operations_4a2a914e", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: stack with push, pop, and peek operations. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_option_type_0cbaf7c1", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that option type with map and get_or_else, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_list_length_e35a623b", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement compute length of a linked list in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_tree_size_9e189b00", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to compute size of a binary tree. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_palindrome_b163337c", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a sequence is a palindrome. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_even_odd_lemma_aab92f26", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: prove that n+2 preserves parity. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_of_squares_a0ed93ba", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify sum of first n squares formula? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_distributive_lemma_f65ca4a1", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: prove distributive property of sequence count. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_df7a9772", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement verify subset properties in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_set_cardinality_034eafde", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that verify set cardinality properties. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_prime_check_ea107b0b", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a number is prime by trial division? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_sqrt_55bfd04c", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute integer square root. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_dutch_flag_55f3b97a", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for dutch national flag partitioning (0s, 1s, 2s)? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_cbb78a5d", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that partition array around a pivot. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_clamp_f552c88c", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: clamp a value to a range. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_safe_divide_54676548", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: safe division returning an option. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_swap_7292740d", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to swap two values using a method with out parameters. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sign_b2cf9d5f", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the sign of an integer. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_f01fecb7", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence contains duplicate elements. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_two_sum_exists_1c9b8253", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if two elements in a sorted array sum to target. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_abs_fe10f4d7", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute absolute value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_max_of_two_5572d6c2", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the maximum of two integers, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_min_of_two_e85c714b", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the minimum of two integers? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_division_8a4cb7bd", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that integer division with remainder, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_power_5779f305", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute x raised to the power n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_factorial_fc7620f7", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute factorial of n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_cc844538", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute the nth fibonacci number. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_gcd_76881f7d", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute greatest common divisor using euclidean algorithm? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_297b297e", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is even. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sum_to_n_4d88b525", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute sum from 1 to n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_sum_ef62be62", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: sum all elements of an array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_max_44ab5769", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that find the maximum element in a non-empty array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_min_6b47282a", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the minimum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_linear_search_33996d77", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement search for a value in an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_search_d7b6b932", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: binary search in a sorted array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_f46117e3", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that reverse an array in place. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_count_occurrences_85d7085f", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: count occurrences of a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_all_positive_4122efb7", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if all elements in an array are positive. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_copy_fdb45f7b", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement copy elements from one array to another in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fill_array_3fdcfc69", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: fill an array with a given value. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_sorted_718d3ef3", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if an array is sorted in non-decreasing order in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_insertion_sort_f09e023d", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: sort an array using insertion sort. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_bubble_sort_pass_f82c6ce6", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for one pass of bubble sort? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_sum_83bba479", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that sum elements of a sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_reverse_52bdbb10", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: reverse a sequence. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_contains_f7c8261b", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence contains a value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_max_7f334946", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement find maximum element in a non-empty sequence in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_stack_operations_318c7084", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: stack with push, pop, and peek operations. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_option_type_b0b9e2f8", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that option type with map and get_or_else, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_list_length_2987c411", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement compute length of a linked list in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_tree_size_9c33adab", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute size of a binary tree. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_palindrome_7950460a", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if a sequence is a palindrome in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_even_odd_lemma_7e5b96bd", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that prove that n+2 preserves parity. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_of_squares_ed10f3dd", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify sum of first n squares formula, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_distributive_lemma_6db2771d", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: prove distributive property of sequence count. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_set_subset_68326328", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: verify subset properties. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_cardinality_49b30c99", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify set cardinality properties, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_prime_check_0ed14dd5", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a number is prime by trial division? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_sqrt_a1246a2a", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute integer square root. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_dutch_flag_d1e3d246", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to dutch national flag partitioning (0s, 1s, 2s). Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_partition_cda41b5c", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: partition array around a pivot. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_clamp_68b863e1", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that clamp a value to a range. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_safe_divide_8544b1d0", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that safe division returning an option, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_swap_bbf522cf", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement swap two values using a method with out parameters in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sign_833572c7", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: return the sign of an integer. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_24006a2e", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence contains duplicate elements. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_two_sum_exists_c38bf264", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if two elements in a sorted array sum to target? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_abs_7cca13ea", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute absolute value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_max_of_two_64b29c74", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: return the maximum of two integers. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_min_of_two_2ce1a6c5", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the minimum of two integers? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_division_ca9e092f", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to integer division with remainder. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_power_0113a277", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute x raised to the power n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_factorial_3b262760", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute factorial of n in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_6258952b", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute the nth fibonacci number. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_gcd_4951cac2", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute greatest common divisor using euclidean algorithm in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_even_433dcee1", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is even. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_to_n_2d4d999f", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute sum from 1 to n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_array_sum_299d68a5", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that sum all elements of an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_max_01b6e747", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement find the maximum element in a non-empty array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_min_65430226", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement find the minimum element in a non-empty array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_linear_search_67a0419c", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement search for a value in an array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_search_643c66f7", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that binary search in a sorted array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_reverse_array_3ebbe2f2", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that reverse an array in place. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_c3063458", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: count occurrences of a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_all_positive_8f4923d5", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if all elements in an array are positive. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_copy_1930c1ee", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: copy elements from one array to another. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fill_array_961a5e75", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that fill an array with a given value, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_sorted_3610fee1", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if an array is sorted in non-decreasing order. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_insertion_sort_75f32235", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement sort an array using insertion sort in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_bubble_sort_pass_8da4063a", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement one pass of bubble sort in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_sum_e09e5077", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: sum elements of a sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_reverse_98e39cd7", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: reverse a sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_contains_7c024461", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if a sequence contains a value in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_max_c0a07c07", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: find maximum element in a non-empty sequence. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_stack_operations_39f06882", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that stack with push, pop, and peek operations. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_option_type_7f7b81b1", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that option type with map and get_or_else. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_list_length_63210905", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement compute length of a linked list in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_tree_size_dbd80b53", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to compute size of a binary tree. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_palindrome_81c8b701", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a sequence is a palindrome in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_even_odd_lemma_1da5fdb1", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for prove that n+2 preserves parity? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsEven(n: nat)\n{\n\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sum_of_squares_5660675e", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement verify sum of first n squares formula in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_distributive_lemma_1b8e95cf", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for prove distributive property of sequence count? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_subset_4c43c34a", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that verify subset properties. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_cardinality_3726092a", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify set cardinality properties? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_prime_check_2ddbd7b2", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a number is prime by trial division. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_sqrt_8a82cd54", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute integer square root. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_dutch_flag_f825a99c", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement dutch national flag partitioning (0s, 1s, 2s) in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_partition_84bb7c79", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that partition array around a pivot, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_clamp_7c8df087", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that clamp a value to a range. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_safe_divide_cb89a752", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that safe division returning an option. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_swap_27a896ac", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: swap two values using a method with out parameters. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sign_727a410b", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the sign of an integer, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_contains_duplicate_f07eaa87", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a sequence contains duplicate elements. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_two_sum_exists_3434eb72", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if two elements in a sorted array sum to target in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_abs_8ba39c0c", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute absolute value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_max_of_two_fdf1115b", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: return the maximum of two integers. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_min_of_two_1d8ecb5a", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the minimum of two integers in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_6d8fd04d", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to integer division with remainder. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_power_f6c94fa4", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute x raised to the power n. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_factorial_7bb31e5f", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute factorial of n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_479cb80e", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute the nth fibonacci number in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_gcd_0404022f", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute greatest common divisor using euclidean algorithm? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_even_54656b53", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a number is even. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_to_n_5526b146", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute sum from 1 to n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_sum_1a5c90c6", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for sum all elements of an array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_max_79f6be08", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: find the maximum element in a non-empty array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_min_0a8e7f56", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find the minimum element in a non-empty array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_linear_search_66f8374b", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: search for a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_search_1fb39b58", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that binary search in a sorted array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_6b182cfc", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: reverse an array in place. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_count_occurrences_ea01e5f7", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that count occurrences of a value in an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_all_positive_f0d2fe4c", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if all elements in an array are positive? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_copy_e1a5ca26", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that copy elements from one array to another, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fill_array_b93afa7d", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that fill an array with a given value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_sorted_b1db88f9", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if an array is sorted in non-decreasing order in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_insertion_sort_10c0e12c", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to sort an array using insertion sort. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_bubble_sort_pass_9d41bc1d", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement one pass of bubble sort in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_sum_46f91813", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that sum elements of a sequence. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_reverse_a2195631", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that reverse a sequence. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_contains_90aa5743", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a sequence contains a value. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_max_4bf41b53", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that find maximum element in a non-empty sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_stack_operations_ad052868", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for stack with push, pop, and peek operations? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_option_type_6a9fcb28", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to option type with map and get_or_else. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_list_length_d7bc40a8", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute length of a linked list. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_tree_size_75d56e68", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute size of a binary tree. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_palindrome_87e377db", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a sequence is a palindrome? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_even_odd_lemma_481908df", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that prove that n+2 preserves parity. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_of_squares_0e9aba83", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that verify sum of first n squares formula. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_distributive_lemma_7b0cde8b", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement prove distributive property of sequence count in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_cd494656", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to verify subset properties. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_set_cardinality_d51ec459", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that verify set cardinality properties. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_prime_check_0c095d46", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a number is prime by trial division. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_sqrt_a4c2e7dd", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute integer square root. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_dutch_flag_281ab27d", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that dutch national flag partitioning (0s, 1s, 2s). Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_partition_ba8a7872", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to partition array around a pivot. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_clamp_c58a1f02", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for clamp a value to a range? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_safe_divide_3e1854ee", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: safe division returning an option. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_swap_8b625e52", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to swap two values using a method with out parameters. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sign_140939f4", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the sign of an integer in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_8424b8d1", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence contains duplicate elements. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_two_sum_exists_853ade96", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if two elements in a sorted array sum to target in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_abs_fe0b4870", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute absolute value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_max_of_two_ed09e0b9", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to return the maximum of two integers. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_min_of_two_7a3624b9", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the minimum of two integers. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_division_b64d1370", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to integer division with remainder. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_power_f7e71f26", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute x raised to the power n, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_factorial_ab4f4788", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute factorial of n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fibonacci_f9820386", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute the nth fibonacci number. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_gcd_e8ae7e33", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute greatest common divisor using euclidean algorithm. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_even_1b19c415", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a number is even? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_to_n_7d714242", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute sum from 1 to n. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_sum_402d215f", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement sum all elements of an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_max_27e3edab", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement find the maximum element in a non-empty array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_min_467e55fc", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the minimum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_linear_search_48a7a0d1", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: search for a value in an array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_search_527937b2", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: binary search in a sorted array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_reverse_array_56c9cef0", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to reverse an array in place. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_count_occurrences_36ca6470", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: count occurrences of a value in an array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_all_positive_5238aca5", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if all elements in an array are positive. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_copy_49b5ed43", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that copy elements from one array to another, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fill_array_4c20f4cb", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that fill an array with a given value. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_04b2c7e1", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if an array is sorted in non-decreasing order. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_insertion_sort_bba29db5", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement sort an array using insertion sort in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_bubble_sort_pass_f4fd007f", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to one pass of bubble sort. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_sum_7676ba32", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum elements of a sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_reverse_bb4a4fdc", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that reverse a sequence, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_bd901192", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if a sequence contains a value in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_max_6d5f4c68", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that find maximum element in a non-empty sequence. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_stack_operations_2dbca2e7", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement stack with push, pop, and peek operations in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_option_type_f0b92bcd", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: option type with map and get_or_else. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_list_length_00b7926e", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement compute length of a linked list in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_tree_size_8714c3fe", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute size of a binary tree. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_palindrome_035b6169", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence is a palindrome. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_even_odd_lemma_f8d3ebd3", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that prove that n+2 preserves parity. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_of_squares_f69bd34b", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify sum of first n squares formula. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_distributive_lemma_a8783619", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that prove distributive property of sequence count. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_subset_2c10003a", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify subset properties? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_cardinality_63d88cc8", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement verify set cardinality properties in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_prime_check_e3a2cc48", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is prime by trial division. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_sqrt_5051b31f", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute integer square root. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_dutch_flag_bb0017b2", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement dutch national flag partitioning (0s, 1s, 2s) in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_partition_2f71f524", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to partition array around a pivot. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_clamp_8f2b652d", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that clamp a value to a range, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_safe_divide_dee66efe", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: safe division returning an option. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_swap_ea5529bc", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: swap two values using a method with out parameters. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sign_64a7bcc5", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the sign of an integer. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_contains_duplicate_b46a5aee", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a sequence contains duplicate elements? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_two_sum_exists_f143968e", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if two elements in a sorted array sum to target? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_abs_9ebaa626", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute absolute value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_max_of_two_261d1c10", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to return the maximum of two integers. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_min_of_two_9909fba8", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the minimum of two integers. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_division_317e4282", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to integer division with remainder. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_power_3cdae5dc", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute x raised to the power n. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_factorial_b9283848", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute factorial of n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fibonacci_cfeb7ecc", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute the nth fibonacci number. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_gcd_c5784342", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute greatest common divisor using euclidean algorithm. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_even_4172966d", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if a number is even in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n\n  result := n % 2 == 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_to_n_915f4a39", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute sum from 1 to n. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_sum_77cf06fa", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that sum all elements of an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_max_cf58f443", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the maximum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_min_9af4420d", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for find the minimum element in a non-empty array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_linear_search_277472cd", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: search for a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_search_d277b6f6", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: binary search in a sorted array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_reverse_array_235c01d5", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that reverse an array in place. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_count_occurrences_e8475c23", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that count occurrences of a value in an array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_all_positive_5119b81e", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if all elements in an array are positive? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_copy_fc8280f4", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to copy elements from one array to another. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fill_array_993b63b2", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement fill an array with a given value in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_sorted_98bbf0ee", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if an array is sorted in non-decreasing order in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_insertion_sort_5d5833c5", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: sort an array using insertion sort. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_2428d2c3", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement one pass of bubble sort in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_sum_86d3c7bf", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: sum elements of a sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_reverse_ae3ec97e", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that reverse a sequence. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_85b47100", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a sequence contains a value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_max_26f92ea8", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that find maximum element in a non-empty sequence, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_stack_operations_4a4bd34a", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for stack with push, pop, and peek operations? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_option_type_60adddd7", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that option type with map and get_or_else. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_list_length_ade0cf34", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute length of a linked list. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_tree_size_511b0733", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute size of a binary tree. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_palindrome_ea0dfc59", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a sequence is a palindrome. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_even_odd_lemma_821d7952", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to prove that n+2 preserves parity. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sum_of_squares_20a3834b", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to verify sum of first n squares formula. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_distributive_lemma_e1eb695b", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to prove distributive property of sequence count. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_subset_24c5d562", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that verify subset properties. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_set_cardinality_4b8bee4b", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: verify set cardinality properties. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_prime_check_a2187e48", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a number is prime by trial division. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_sqrt_5c8326f7", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute integer square root. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_dutch_flag_64ae2847", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that dutch national flag partitioning (0s, 1s, 2s), with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_partition_02641c87", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: partition array around a pivot. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_clamp_ac06fedf", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: clamp a value to a range. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_safe_divide_f84493bc", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement safe division returning an option in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_swap_6ae50e1d", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that swap two values using a method with out parameters. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n\n  x := b;\n  y := a;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sign_e20bb596", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the sign of an integer in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_contains_duplicate_03232b35", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a sequence contains duplicate elements. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_two_sum_exists_e10dca28", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if two elements in a sorted array sum to target in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_abs_ef6d381b", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute absolute value. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_max_of_two_42f3cf76", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the maximum of two integers. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_min_of_two_4302fde9", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement return the minimum of two integers in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_division_07498dd0", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: integer division with remainder. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_power_2f7d3ecb", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute x raised to the power n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_factorial_e502f11e", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute factorial of n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_cddd68c8", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute the nth fibonacci number? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_gcd_a4aa5c2c", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute greatest common divisor using euclidean algorithm in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_d0b481ad", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is even. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_to_n_f7889af4", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute sum from 1 to n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_sum_96bdde89", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to sum all elements of an array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_max_5f9678f1", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the maximum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_min_d3e269ac", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find the minimum element in a non-empty array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_linear_search_8511e23a", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to search for a value in an array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_search_0637e083", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: binary search in a sorted array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_reverse_array_f2c49cc8", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: reverse an array in place. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_count_occurrences_71916ff5", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement count occurrences of a value in an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_all_positive_a7a029cd", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if all elements in an array are positive. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_array_copy_7d87d666", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that copy elements from one array to another. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fill_array_cc458786", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: fill an array with a given value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_sorted_b1f61e8c", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if an array is sorted in non-decreasing order in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_insertion_sort_1eeba637", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that sort an array using insertion sort. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_2909d893", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that one pass of bubble sort. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_sum_47294139", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: sum elements of a sequence. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_reverse_94318267", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: reverse a sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_contains_fa9acdb9", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a sequence contains a value, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_max_18696a8c", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement find maximum element in a non-empty sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_stack_operations_7cf265e0", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: stack with push, pop, and peek operations. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_option_type_b212d5cc", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that option type with map and get_or_else, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_list_length_36f80334", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement compute length of a linked list in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_tree_size_96c4c9f9", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that compute size of a binary tree. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_palindrome_b97f348c", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a sequence is a palindrome. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_even_odd_lemma_017b54c6", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that prove that n+2 preserves parity, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_of_squares_a16951b4", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to verify sum of first n squares formula. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_distributive_lemma_203ce4ba", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for prove distributive property of sequence count? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_subset_6b3c2f42", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement verify subset properties in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_cardinality_46824514", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement verify set cardinality properties in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_prime_check_2ab2c64b", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a number is prime by trial division? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_sqrt_7dc8d8fd", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute integer square root in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_dutch_flag_7423ef46", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: dutch national flag partitioning (0s, 1s, 2s). Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_partition_a8282a17", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that partition array around a pivot, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_clamp_a254ff7c", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement clamp a value to a range in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_safe_divide_2bd282e7", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that safe division returning an option, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_swap_2954540c", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that swap two values using a method with out parameters. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sign_fe793d44", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the sign of an integer in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_contains_duplicate_cde7a1a9", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a sequence contains duplicate elements. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_two_sum_exists_a5fbb273", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if two elements in a sorted array sum to target. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_abs_81c6768e", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute absolute value. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_max_of_two_6050f20f", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the maximum of two integers. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_min_of_two_0631058a", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the minimum of two integers, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_caa93e39", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to integer division with remainder. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_power_93b8ca70", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute x raised to the power n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_factorial_f08346d6", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute factorial of n. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_bb02eeb3", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute the nth fibonacci number in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_gcd_e060a686", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute greatest common divisor using euclidean algorithm, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_df88912d", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a number is even. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_to_n_f5c74e8c", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute sum from 1 to n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_sum_b20bbb70", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that sum all elements of an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_max_9788475d", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: find the maximum element in a non-empty array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_min_d3321927", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement find the minimum element in a non-empty array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_linear_search_3b946d14", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement search for a value in an array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_search_34aaf826", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: binary search in a sorted array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_06839876", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement reverse an array in place in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_d40de14e", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: count occurrences of a value in an array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_all_positive_621982d8", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if all elements in an array are positive. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_copy_a172de6c", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that copy elements from one array to another. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fill_array_f504217a", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that fill an array with a given value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_sorted_595cda1b", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if an array is sorted in non-decreasing order in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_insertion_sort_0b016e4e", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that sort an array using insertion sort, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_21409f23", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: one pass of bubble sort. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_sum_19dff8ed", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum elements of a sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_reverse_165896d4", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that reverse a sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_8174a5c0", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a sequence contains a value. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_max_1a22c9a8", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find maximum element in a non-empty sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_stack_operations_03656447", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement stack with push, pop, and peek operations in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_option_type_2f516ef6", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: option type with map and get_or_else. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_list_length_5e3942f0", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement compute length of a linked list in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_tree_size_8056e5ab", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute size of a binary tree. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_palindrome_a3f65cf2", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a sequence is a palindrome. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_even_odd_lemma_bbd2e86f", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: prove that n+2 preserves parity. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_of_squares_5f6bc29b", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify sum of first n squares formula? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_distributive_lemma_7bb037d4", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: prove distributive property of sequence count. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_9055b3d7", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify subset properties, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_cardinality_1db95e3a", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that verify set cardinality properties. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_prime_check_737cd2ef", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is prime by trial division. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_sqrt_0fb17b32", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute integer square root. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_dutch_flag_3b009c6e", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that dutch national flag partitioning (0s, 1s, 2s), with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_5da282bf", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that partition array around a pivot. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_clamp_53050c50", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement clamp a value to a range in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_safe_divide_df8340e4", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement safe division returning an option in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_swap_6e318d61", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement swap two values using a method with out parameters in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sign_619602cf", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the sign of an integer. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_5fdea095", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a sequence contains duplicate elements. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_two_sum_exists_deb46cb8", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if two elements in a sorted array sum to target in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_abs_011fbb32", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute absolute value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_max_of_two_2da155b6", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the maximum of two integers. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_min_of_two_532837db", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement return the minimum of two integers in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_f07b3ba9", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement integer division with remainder in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_power_297eb86b", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute x raised to the power n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_factorial_f3b467a9", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute factorial of n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_08de83f5", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute the nth fibonacci number? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_gcd_67845c88", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute greatest common divisor using euclidean algorithm, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_even_48b64be8", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a number is even? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_to_n_a3330c68", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute sum from 1 to n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_sum_9a1c1183", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement sum all elements of an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_max_1d25d93c", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that find the maximum element in a non-empty array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_min_2a3d49d7", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement find the minimum element in a non-empty array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_linear_search_7b43565a", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: search for a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_search_aa7a9d79", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement binary search in a sorted array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_reverse_array_ae997d85", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: reverse an array in place. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_count_occurrences_e9bf475c", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: count occurrences of a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_all_positive_bcb990ef", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if all elements in an array are positive. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_copy_fe88e317", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that copy elements from one array to another. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fill_array_7df38209", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: fill an array with a given value. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_sorted_71ab69da", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if an array is sorted in non-decreasing order. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_insertion_sort_497890dc", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that sort an array using insertion sort. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_bubble_sort_pass_645df4a4", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for one pass of bubble sort? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_sum_d15a1452", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum elements of a sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_reverse_e3b3525e", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that reverse a sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_contains_3511ffe8", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence contains a value. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_max_b6f917ea", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for find maximum element in a non-empty sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_stack_operations_0164ef74", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that stack with push, pop, and peek operations. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_option_type_e84ca298", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to option type with map and get_or_else. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_list_length_144cf4c3", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that compute length of a linked list. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_tree_size_25e1527e", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for compute size of a binary tree? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_palindrome_7df089ff", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a sequence is a palindrome in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_even_odd_lemma_da3d3f50", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement prove that n+2 preserves parity in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsEven(n: nat)\n{\n\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_of_squares_015e863b", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to verify sum of first n squares formula. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_distributive_lemma_3a6efdc7", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to prove distributive property of sequence count. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_subset_f94ff0b8", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: verify subset properties. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_cardinality_ce02fb86", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that verify set cardinality properties. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_prime_check_37031b4c", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if a number is prime by trial division in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_sqrt_ccc44afc", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute integer square root? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_dutch_flag_4a3c9332", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: dutch national flag partitioning (0s, 1s, 2s). Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_5854cd1f", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to partition array around a pivot. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_clamp_c094251e", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to clamp a value to a range. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_safe_divide_c6276c2f", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: safe division returning an option. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_swap_e87a4055", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: swap two values using a method with out parameters. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sign_3692d97c", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the sign of an integer, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_contains_duplicate_85daeee8", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a sequence contains duplicate elements. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_two_sum_exists_b27e3291", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if two elements in a sorted array sum to target. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_abs_e67eba88", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement compute absolute value in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_max_of_two_296ffbab", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: return the maximum of two integers. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_min_of_two_3f482781", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: return the minimum of two integers. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_fb37422e", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to integer division with remainder. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_power_b2d26827", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute x raised to the power n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_factorial_eb11f2cd", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute factorial of n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fibonacci_7f9edccd", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute the nth fibonacci number, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_gcd_c2d671aa", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute greatest common divisor using euclidean algorithm in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_even_7a803b25", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a number is even? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_to_n_ab4159f2", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute sum from 1 to n, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_sum_43c13d84", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that sum all elements of an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_max_5e34779f", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: find the maximum element in a non-empty array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_min_8346cf4d", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the minimum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_linear_search_9c561ca1", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that search for a value in an array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_search_429b2c87", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to binary search in a sorted array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_998caec2", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that reverse an array in place. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_c8e0e028", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement count occurrences of a value in an array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_all_positive_0b47a99f", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if all elements in an array are positive. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_array_copy_f51313e7", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to copy elements from one array to another. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fill_array_042162d4", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to fill an array with a given value. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_e2ef6bcf", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if an array is sorted in non-decreasing order. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_insertion_sort_a4d6ef74", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: sort an array using insertion sort. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_bubble_sort_pass_461f06ea", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement one pass of bubble sort in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_sum_608f66a8", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that sum elements of a sequence. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_reverse_30f8557c", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: reverse a sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_contains_0bcc17c6", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a sequence contains a value. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_max_8529c989", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: find maximum element in a non-empty sequence. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_stack_operations_386a1dde", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement stack with push, pop, and peek operations in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_option_type_383a853e", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that option type with map and get_or_else, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_list_length_294b511c", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute length of a linked list. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_tree_size_f00c1934", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute size of a binary tree. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_palindrome_4954d8a8", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a sequence is a palindrome. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_even_odd_lemma_a4ecc69a", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that prove that n+2 preserves parity. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_of_squares_8b69070f", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify sum of first n squares formula, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_distributive_lemma_19a2c749", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement prove distributive property of sequence count in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_a0be9f53", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement verify subset properties in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_cardinality_11a89536", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify set cardinality properties? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_prime_check_867e8780", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a number is prime by trial division. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_sqrt_16180f62", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute integer square root in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_dutch_flag_d57af772", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement dutch national flag partitioning (0s, 1s, 2s) in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_804560ee", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that partition array around a pivot. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_clamp_d50559bd", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that clamp a value to a range. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_safe_divide_1fc7c1d9", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to safe division returning an option. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_swap_a8d0265f", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement swap two values using a method with out parameters in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sign_b519cedd", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: return the sign of an integer. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_contains_duplicate_1908010b", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a sequence contains duplicate elements in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_two_sum_exists_3cae10d7", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if two elements in a sorted array sum to target, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_abs_6ffd2675", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute absolute value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_max_of_two_1489fe5d", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to return the maximum of two integers. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_min_of_two_2526e82a", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that return the minimum of two integers. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_division_4b860bd2", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: integer division with remainder. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_power_603b914d", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute x raised to the power n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_factorial_d2ac363f", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute factorial of n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fibonacci_f19e52e9", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute the nth fibonacci number, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_gcd_777e8c44", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute greatest common divisor using euclidean algorithm in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_even_6acd645c", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a number is even. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_to_n_6a17ac29", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute sum from 1 to n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_sum_d70f58bd", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: sum all elements of an array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_max_8cc5d7de", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that find the maximum element in a non-empty array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_min_3a07190c", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: find the minimum element in a non-empty array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_linear_search_41613c2c", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that search for a value in an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_search_3cd34727", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: binary search in a sorted array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_cc037d6d", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to reverse an array in place. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_count_occurrences_f56b46e5", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: count occurrences of a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_all_positive_62b01d11", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if all elements in an array are positive. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_array_copy_cc504b9e", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for copy elements from one array to another? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_fill_array_dbe38f78", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that fill an array with a given value, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_d2b7e8c2", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if an array is sorted in non-decreasing order. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_insertion_sort_e4c56957", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement sort an array using insertion sort in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_bubble_sort_pass_12774589", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that one pass of bubble sort, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_sum_a8b67c46", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum elements of a sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_reverse_76a94795", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: reverse a sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_7b39201d", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if a sequence contains a value in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_max_88f9b1b5", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for find maximum element in a non-empty sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_stack_operations_db8cd38b", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: stack with push, pop, and peek operations. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_option_type_5a0f9e27", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement option type with map and get_or_else in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_list_length_f405a881", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to compute length of a linked list. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_tree_size_a2d8760f", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute size of a binary tree in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_palindrome_1aea1f12", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a sequence is a palindrome. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_even_odd_lemma_255857cc", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement prove that n+2 preserves parity in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_of_squares_ab23a1fb", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify sum of first n squares formula. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_distributive_lemma_e381ab95", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: prove distributive property of sequence count. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_set_subset_dbc3c224", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify subset properties, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_cardinality_2cb918f6", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement verify set cardinality properties in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_prime_check_43092a36", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a number is prime by trial division. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_sqrt_7a5af50a", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute integer square root? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_dutch_flag_e53b4235", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that dutch national flag partitioning (0s, 1s, 2s). It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_838a3b74", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that partition array around a pivot. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_clamp_294df248", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement clamp a value to a range in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_safe_divide_9ca8262f", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that safe division returning an option. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_swap_b679595f", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement swap two values using a method with out parameters in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sign_354fb4bc", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the sign of an integer, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_contains_duplicate_acc3b3ed", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a sequence contains duplicate elements, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_two_sum_exists_91b29cde", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if two elements in a sorted array sum to target in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_abs_804d94bc", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute absolute value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_max_of_two_623cdd96", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: return the maximum of two integers. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_min_of_two_bb3c28d6", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: return the minimum of two integers. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_division_78cd6a13", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that integer division with remainder. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_power_f26715df", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute x raised to the power n. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_factorial_4b0336ae", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute factorial of n. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_ce596bb8", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute the nth fibonacci number. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_gcd_afdb5887", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute greatest common divisor using euclidean algorithm. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_even_3ab4f762", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a number is even. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n\n  result := n % 2 == 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sum_to_n_8eda3d16", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute sum from 1 to n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_sum_2bd7981f", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for sum all elements of an array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_max_c6fd3234", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that find the maximum element in a non-empty array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_min_7b990fee", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for find the minimum element in a non-empty array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_linear_search_77883369", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement search for a value in an array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_search_fd67df74", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: binary search in a sorted array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_reverse_array_83203ecf", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement reverse an array in place in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_97396e2e", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement count occurrences of a value in an array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_all_positive_4f5e8d26", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if all elements in an array are positive. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_array_copy_c978530a", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: copy elements from one array to another. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_fill_array_cbaa0a81", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for fill an array with a given value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_sorted_63bc97fc", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if an array is sorted in non-decreasing order. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_insertion_sort_685edc18", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that sort an array using insertion sort. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_dfd522fc", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that one pass of bubble sort. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_sum_98463234", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum elements of a sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_reverse_9044403d", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement reverse a sequence in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_79b30b70", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if a sequence contains a value in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_max_17ddff0d", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for find maximum element in a non-empty sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_stack_operations_32e8661e", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that stack with push, pop, and peek operations. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_option_type_ca57982a", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: option type with map and get_or_else. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_list_length_0820b67e", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement compute length of a linked list in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_tree_size_7bda1ae9", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute size of a binary tree in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_palindrome_431c83f7", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a sequence is a palindrome in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_even_odd_lemma_2c8d9af4", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for prove that n+2 preserves parity? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_of_squares_85ec58f4", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: verify sum of first n squares formula. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_distributive_lemma_95688c06", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to prove distributive property of sequence count. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_set_subset_7eb5b827", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that verify subset properties. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_set_cardinality_c3c07a67", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to verify set cardinality properties. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_prime_check_ca665e52", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if a number is prime by trial division in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_integer_sqrt_1d141391", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute integer square root. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_dutch_flag_038da0eb", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that dutch national flag partitioning (0s, 1s, 2s). Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_partition_c8e264f8", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for partition array around a pivot? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_clamp_24d796e3", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement clamp a value to a range in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_safe_divide_66988844", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: safe division returning an option. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_swap_09b3dcb7", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement swap two values using a method with out parameters in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sign_40eaebcd", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement return the sign of an integer in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_contains_duplicate_132c5213", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a sequence contains duplicate elements. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_two_sum_exists_af4948cf", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if two elements in a sorted array sum to target. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_abs_d2268720", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute absolute value. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_max_of_two_4a2938d7", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the maximum of two integers. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_min_of_two_4d06591d", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the minimum of two integers. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_3489205f", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that integer division with remainder. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_power_124c537b", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute x raised to the power n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_factorial_0cf5064a", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute factorial of n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fibonacci_f44b5b36", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute the nth fibonacci number? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_gcd_0812cecc", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute greatest common divisor using euclidean algorithm? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_even_017ac98b", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a number is even. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_to_n_e78c6682", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute sum from 1 to n, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_sum_d62ed025", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that sum all elements of an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_max_b7cb8fb8", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to find the maximum element in a non-empty array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_min_07586f84", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: find the minimum element in a non-empty array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_linear_search_9b3c7a52", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: search for a value in an array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_search_ab81ff1a", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: binary search in a sorted array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_a386b6a6", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for reverse an array in place? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_4a53e626", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that count occurrences of a value in an array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_all_positive_cc32af68", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if all elements in an array are positive. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_copy_3bd962e0", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: copy elements from one array to another. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fill_array_381ba048", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that fill an array with a given value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_a89b4093", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if an array is sorted in non-decreasing order. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_insertion_sort_274ab821", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: sort an array using insertion sort. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_bubble_sort_pass_fd5d28b3", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement one pass of bubble sort in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_sum_30c7b588", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that sum elements of a sequence. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_reverse_06afcdad", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: reverse a sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_contains_370b3e9d", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if a sequence contains a value in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_max_23be47d5", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement find maximum element in a non-empty sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_stack_operations_96ff605d", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that stack with push, pop, and peek operations, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_option_type_d3ec2fa4", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to option type with map and get_or_else. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_list_length_0a7de059", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute length of a linked list. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_tree_size_353017f1", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that compute size of a binary tree. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_palindrome_84a8311d", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if a sequence is a palindrome in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_even_odd_lemma_4c5ff4d3", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: prove that n+2 preserves parity. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_of_squares_4b11232c", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: verify sum of first n squares formula. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_distributive_lemma_e68556b3", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for prove distributive property of sequence count? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_set_subset_adc2f101", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement verify subset properties in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_cardinality_57d1e805", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify set cardinality properties? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_prime_check_0dca88a0", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if a number is prime by trial division in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_sqrt_cc82651c", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute integer square root in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_dutch_flag_16b5ab02", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that dutch national flag partitioning (0s, 1s, 2s). Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_partition_46dd0f90", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: partition array around a pivot. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_clamp_81016069", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that clamp a value to a range. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_safe_divide_ec176fbc", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: safe division returning an option. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_swap_3833acfd", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement swap two values using a method with out parameters in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sign_cc343b6b", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the sign of an integer? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_e8e4690a", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a sequence contains duplicate elements, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_two_sum_exists_d9c97ca5", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if two elements in a sorted array sum to target. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_abs_65442c09", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute absolute value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_max_of_two_6bb86d6c", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the maximum of two integers, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_min_of_two_cf527970", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: return the minimum of two integers. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_6894d735", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement integer division with remainder in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_power_50f667ce", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute x raised to the power n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_factorial_6799f0fd", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute factorial of n in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fibonacci_c6cddaaa", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute the nth fibonacci number, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_gcd_558e0a65", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute greatest common divisor using euclidean algorithm? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_9275f3af", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is even. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_to_n_55f4313f", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute sum from 1 to n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_sum_b43f97a8", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to sum all elements of an array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_max_431d029e", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that find the maximum element in a non-empty array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_min_d107c69f", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for find the minimum element in a non-empty array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_linear_search_63d7fc54", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: search for a value in an array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_search_04222e7b", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for binary search in a sorted array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_7006896f", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: reverse an array in place. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_ed936d4b", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to count occurrences of a value in an array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_all_positive_845dc7ea", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if all elements in an array are positive. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_copy_92010817", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement copy elements from one array to another in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_fill_array_9bf77352", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement fill an array with a given value in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_sorted_49ae7cb0", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if an array is sorted in non-decreasing order? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_insertion_sort_99035d1e", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that sort an array using insertion sort, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_bubble_sort_pass_ee9b6eac", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: one pass of bubble sort. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_sum_1a84c9f6", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: sum elements of a sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_reverse_b2b6e854", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: reverse a sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_26eceb8c", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence contains a value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_max_2e0752eb", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find maximum element in a non-empty sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_stack_operations_011fed7e", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: stack with push, pop, and peek operations. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_option_type_e43dc8b9", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that option type with map and get_or_else. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_list_length_5c8dadf2", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement compute length of a linked list in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_tree_size_afb3f644", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute size of a binary tree. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_palindrome_e1a8f2f9", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a sequence is a palindrome. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_even_odd_lemma_4d76cec3", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that prove that n+2 preserves parity, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_of_squares_ff8df608", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement verify sum of first n squares formula in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_distributive_lemma_ad56e3d6", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: prove distributive property of sequence count. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_set_subset_964a1f25", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to verify subset properties. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_cardinality_df6fbcf4", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that verify set cardinality properties. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_prime_check_3a72ffa6", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a number is prime by trial division. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_sqrt_14a7f481", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute integer square root. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_dutch_flag_55636f3e", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: dutch national flag partitioning (0s, 1s, 2s). Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_partition_93db3e46", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that partition array around a pivot. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_clamp_b7183e39", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: clamp a value to a range. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_safe_divide_746383b6", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: safe division returning an option. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_swap_1139951c", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: swap two values using a method with out parameters. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sign_0ef853d4", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the sign of an integer. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_contains_duplicate_a3084177", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a sequence contains duplicate elements. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_two_sum_exists_9c2e1334", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if two elements in a sorted array sum to target. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_abs_9760d4f7", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute absolute value. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_max_of_two_9f96fcc5", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the maximum of two integers? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_min_of_two_ce37f953", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to return the minimum of two integers. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_division_e5737e47", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: integer division with remainder. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_power_7e27150b", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute x raised to the power n. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_factorial_f83bea4f", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute factorial of n. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fibonacci_45b62909", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute the nth fibonacci number. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_gcd_0be7f8ae", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute greatest common divisor using euclidean algorithm. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_b6d650d0", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is even. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sum_to_n_4c30d529", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute sum from 1 to n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_sum_59639c18", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement sum all elements of an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_max_c13dcf35", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find the maximum element in a non-empty array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_min_e8644cc6", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: find the minimum element in a non-empty array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_linear_search_02c605e8", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: search for a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_search_41ab180e", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for binary search in a sorted array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_reverse_array_c6ae227c", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: reverse an array in place. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_ec078ac8", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: count occurrences of a value in an array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_all_positive_4c79015c", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if all elements in an array are positive. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_array_copy_e75e45e7", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to copy elements from one array to another. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fill_array_4f0da573", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement fill an array with a given value in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_sorted_c1545940", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if an array is sorted in non-decreasing order. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_insertion_sort_072868a2", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to sort an array using insertion sort. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_bubble_sort_pass_bbdb09da", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: one pass of bubble sort. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_sum_07163ab6", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum elements of a sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_reverse_d5d4327c", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for reverse a sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_contains_9a37c991", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a sequence contains a value, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_max_56397c10", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: find maximum element in a non-empty sequence. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_stack_operations_be992794", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to stack with push, pop, and peek operations. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_option_type_2be0739e", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for option type with map and get_or_else? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_list_length_b1009032", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement compute length of a linked list in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_tree_size_7d19455f", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute size of a binary tree in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_palindrome_cf459469", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a sequence is a palindrome. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_even_odd_lemma_19fa7d55", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that prove that n+2 preserves parity. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sum_of_squares_4a9de854", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that verify sum of first n squares formula. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_distributive_lemma_3559ffb7", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that prove distributive property of sequence count. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_set_subset_cfce365d", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that verify subset properties. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_set_cardinality_ce0059ca", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that verify set cardinality properties. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_prime_check_e934fc8a", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a number is prime by trial division, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_integer_sqrt_1345e46d", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute integer square root. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_dutch_flag_b551b900", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that dutch national flag partitioning (0s, 1s, 2s). Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_ef240de3", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for partition array around a pivot? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_clamp_41f79f80", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that clamp a value to a range, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_safe_divide_54d25a68", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement safe division returning an option in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_swap_c2717792", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that swap two values using a method with out parameters. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sign_fff4cb8c", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: return the sign of an integer. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_contains_duplicate_05a0ed69", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a sequence contains duplicate elements. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_two_sum_exists_fcb6946b", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if two elements in a sorted array sum to target. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_abs_8d3d1845", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute absolute value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_max_of_two_5a09d3cd", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: return the maximum of two integers. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_min_of_two_b59507dd", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the minimum of two integers. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_division_554141a9", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that integer division with remainder. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_power_05d9345f", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute x raised to the power n. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_factorial_8de883e0", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute factorial of n in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fibonacci_d4dfe4f1", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute the nth fibonacci number. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_gcd_2064273e", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute greatest common divisor using euclidean algorithm in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_even_bb058c87", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a number is even. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_to_n_afda0c75", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute sum from 1 to n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_sum_5c62d173", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that sum all elements of an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_max_61c3092d", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: find the maximum element in a non-empty array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_min_8ceacef2", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find the minimum element in a non-empty array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_linear_search_16c6bd93", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: search for a value in an array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_search_671d6105", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: binary search in a sorted array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_reverse_array_107e7de4", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement reverse an array in place in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_count_occurrences_75dbe381", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement count occurrences of a value in an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_all_positive_71baa25e", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if all elements in an array are positive in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_copy_8b991183", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that copy elements from one array to another, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fill_array_1dba3b24", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement fill an array with a given value in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_sorted_aae3695c", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if an array is sorted in non-decreasing order. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_insertion_sort_1272b05a", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that sort an array using insertion sort. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_bubble_sort_pass_ec6eacea", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement one pass of bubble sort in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_sum_34bcf7bd", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: sum elements of a sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_reverse_a8bbf3b9", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: reverse a sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_contains_673b7670", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a sequence contains a value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_max_a785cd76", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that find maximum element in a non-empty sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_stack_operations_258e1f07", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to stack with push, pop, and peek operations. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_option_type_274c312b", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to option type with map and get_or_else. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_list_length_e94c603b", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute length of a linked list. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_tree_size_428b7fe4", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute size of a binary tree in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_palindrome_ccc5e4f9", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence is a palindrome. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_even_odd_lemma_a6740f4d", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: prove that n+2 preserves parity. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sum_of_squares_cfd4edcb", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement verify sum of first n squares formula in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_distributive_lemma_e72015d9", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that prove distributive property of sequence count. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_subset_bffcc69d", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: verify subset properties. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_set_cardinality_dbdfbc33", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify set cardinality properties. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_prime_check_dbdecd84", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a number is prime by trial division? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_sqrt_583be576", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute integer square root in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_dutch_flag_c1d80271", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: dutch national flag partitioning (0s, 1s, 2s). Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_partition_c65b9bfc", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that partition array around a pivot, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_clamp_ce9b3561", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: clamp a value to a range. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_safe_divide_e0e24e74", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to safe division returning an option. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_swap_644aca4a", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: swap two values using a method with out parameters. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sign_f643b824", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the sign of an integer? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_c85a223b", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a sequence contains duplicate elements. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_two_sum_exists_59f56b82", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if two elements in a sorted array sum to target, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_abs_1e548b8a", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute absolute value. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_max_of_two_d77e865e", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to return the maximum of two integers. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_min_of_two_837e4422", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the minimum of two integers? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_division_1ebac26d", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: integer division with remainder. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_power_b05f8ed8", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute x raised to the power n. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_factorial_ae2890d7", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute factorial of n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fibonacci_f6bb5606", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute the nth fibonacci number. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_gcd_97c65fc1", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute greatest common divisor using euclidean algorithm. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_even_2cd0abd6", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if a number is even in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_to_n_b66584dc", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute sum from 1 to n in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_array_sum_6807ce91", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that sum all elements of an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_max_7eaae42a", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for find the maximum element in a non-empty array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_min_1a26853c", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to find the minimum element in a non-empty array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_linear_search_2b80dabb", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement search for a value in an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_search_21b129d5", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that binary search in a sorted array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_eb3d6fb1", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement reverse an array in place in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_count_occurrences_5dc09e7b", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: count occurrences of a value in an array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_all_positive_8a5ae8cf", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if all elements in an array are positive, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_copy_a3fa2ea1", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that copy elements from one array to another. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_fill_array_439245f4", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that fill an array with a given value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_a39b1361", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if an array is sorted in non-decreasing order. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_insertion_sort_41dd0734", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that sort an array using insertion sort. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_431bf00f", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to one pass of bubble sort. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_sum_bbd75fca", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: sum elements of a sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_reverse_0029be9b", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement reverse a sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_c4bbd16d", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if a sequence contains a value in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_max_644d7dd2", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement find maximum element in a non-empty sequence in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_stack_operations_dc5471c1", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that stack with push, pop, and peek operations. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_option_type_26391bdc", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: option type with map and get_or_else. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_list_length_2dc2c25a", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that compute length of a linked list. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_tree_size_c0f3a1c9", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute size of a binary tree in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_palindrome_36354d36", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence is a palindrome. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_even_odd_lemma_b3d07496", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: prove that n+2 preserves parity. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_of_squares_9dcb519c", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify sum of first n squares formula. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_distributive_lemma_6208cb32", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that prove distributive property of sequence count. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_f8086319", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: verify subset properties. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_cardinality_ab05014d", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: verify set cardinality properties. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_prime_check_3417d29b", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a number is prime by trial division, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_sqrt_f47badb0", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute integer square root in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_dutch_flag_8d5fbc73", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that dutch national flag partitioning (0s, 1s, 2s). Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_partition_aeff0dd7", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that partition array around a pivot. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_clamp_cb0060c2", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that clamp a value to a range. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_safe_divide_8a288e0d", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: safe division returning an option. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_swap_961a0904", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to swap two values using a method with out parameters. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sign_3d8f8fb5", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the sign of an integer in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_fb365c4d", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence contains duplicate elements. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_two_sum_exists_19d76bbc", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if two elements in a sorted array sum to target. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_abs_672407cd", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute absolute value, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_max_of_two_a8697471", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: return the maximum of two integers. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_min_of_two_a5363582", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: return the minimum of two integers. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_integer_division_c5a9c78c", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for integer division with remainder? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_power_1e1726a3", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute x raised to the power n. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_factorial_a348be9d", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute factorial of n, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_fibonacci_f9c86aaf", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute the nth fibonacci number? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_gcd_0c236a2f", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute greatest common divisor using euclidean algorithm in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_14cf3d92", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a number is even? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sum_to_n_f8ac6294", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute sum from 1 to n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_sum_2da8be13", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to sum all elements of an array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_max_39a6d403", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find the maximum element in a non-empty array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_min_5f813733", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find the minimum element in a non-empty array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_linear_search_0fe83e3c", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: search for a value in an array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_search_0dabab2d", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to binary search in a sorted array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_reverse_array_a70132d1", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that reverse an array in place. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_01540d6d", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: count occurrences of a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_all_positive_949bd5d8", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if all elements in an array are positive. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_copy_d1bdcc38", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that copy elements from one array to another. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_fill_array_f2c284ba", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to fill an array with a given value. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_418ddabd", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if an array is sorted in non-decreasing order? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_insertion_sort_8344b044", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for sort an array using insertion sort? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_bubble_sort_pass_878606de", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: one pass of bubble sort. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_sum_a4ed37dd", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: sum elements of a sequence. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_reverse_6650535f", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: reverse a sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_contains_25f4ad3c", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if a sequence contains a value in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_max_825dfa95", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that find maximum element in a non-empty sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_stack_operations_5e1d471f", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that stack with push, pop, and peek operations. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_option_type_20091695", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that option type with map and get_or_else. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_list_length_13d817b3", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for compute length of a linked list? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_tree_size_314ee73f", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute size of a binary tree in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_palindrome_9c81c5c9", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a sequence is a palindrome, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_even_odd_lemma_2170b90b", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for prove that n+2 preserves parity? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sum_of_squares_36371bde", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify sum of first n squares formula, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_distributive_lemma_21436134", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that prove distributive property of sequence count. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_subset_94d2172d", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify subset properties, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_set_cardinality_4c8ab303", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: verify set cardinality properties. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_prime_check_0856a2e9", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a number is prime by trial division. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_sqrt_9f40b4b5", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute integer square root. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_dutch_flag_96b51b9e", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for dutch national flag partitioning (0s, 1s, 2s)? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_partition_78560fc9", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that partition array around a pivot. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_clamp_e64cc71e", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that clamp a value to a range. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_safe_divide_565e14b9", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that safe division returning an option, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_swap_5a878257", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement swap two values using a method with out parameters in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sign_b7ee70d7", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the sign of an integer? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_contains_duplicate_57b45377", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a sequence contains duplicate elements, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_two_sum_exists_0522e215", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if two elements in a sorted array sum to target. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_abs_97377567", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute absolute value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_max_of_two_0c4816ae", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: return the maximum of two integers. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_min_of_two_a498d1d9", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the minimum of two integers. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_5400690d", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that integer division with remainder, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_power_7927cdab", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute x raised to the power n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_factorial_30e150b3", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute factorial of n. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fibonacci_3adc771a", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute the nth fibonacci number in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_gcd_da1cf687", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute greatest common divisor using euclidean algorithm. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_cb4e645c", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a number is even. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_to_n_0b88a428", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute sum from 1 to n, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_array_sum_af839c0d", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum all elements of an array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_max_3645a271", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the maximum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_min_5c70fa7a", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that find the minimum element in a non-empty array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_linear_search_1f9f0ab1", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that search for a value in an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_search_a3c2c86f", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that binary search in a sorted array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_reverse_array_f3cccce1", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that reverse an array in place, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_count_occurrences_f10c2a17", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that count occurrences of a value in an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_all_positive_800182a1", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if all elements in an array are positive. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_array_copy_578cc1fb", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: copy elements from one array to another. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fill_array_c1f4347b", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for fill an array with a given value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_sorted_1828fc18", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if an array is sorted in non-decreasing order. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_insertion_sort_55c231b9", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: sort an array using insertion sort. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_0c1da6f2", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that one pass of bubble sort, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_sum_63716c74", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that sum elements of a sequence, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_reverse_574986a2", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: reverse a sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_contains_2fba9825", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a sequence contains a value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_max_0c29a611", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: find maximum element in a non-empty sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_stack_operations_c065163d", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: stack with push, pop, and peek operations. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_option_type_2f79d272", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: option type with map and get_or_else. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_list_length_d240681e", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that compute length of a linked list. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_tree_size_356b2d44", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for compute size of a binary tree? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_palindrome_32fb5955", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence is a palindrome. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_even_odd_lemma_e2e619df", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement prove that n+2 preserves parity in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_of_squares_9ba5b2cc", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement verify sum of first n squares formula in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_distributive_lemma_a5d3f1e6", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement prove distributive property of sequence count in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_set_subset_fc4e283f", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement verify subset properties in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_cardinality_8aea91c8", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that verify set cardinality properties. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_prime_check_0674bb1a", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is prime by trial division. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_sqrt_c990ceca", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute integer square root in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_dutch_flag_03048563", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that dutch national flag partitioning (0s, 1s, 2s). Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_partition_d976c260", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement partition array around a pivot in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_clamp_9d847216", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: clamp a value to a range. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_safe_divide_91ada510", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: safe division returning an option. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_swap_c5233ac1", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement swap two values using a method with out parameters in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sign_28a9f684", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the sign of an integer, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_e162f7b2", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if a sequence contains duplicate elements in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_two_sum_exists_bc9da93b", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if two elements in a sorted array sum to target? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_abs_c0739ba1", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute absolute value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_max_of_two_2c8fbbf0", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the maximum of two integers. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_min_of_two_79ab9bb9", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the minimum of two integers, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_division_c185088e", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: integer division with remainder. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_power_937ca83f", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute x raised to the power n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_factorial_f7510859", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute factorial of n. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_24acd435", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute the nth fibonacci number. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_gcd_fb1fb3b0", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute greatest common divisor using euclidean algorithm. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_even_5c6d61ec", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is even. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sum_to_n_d287f49c", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute sum from 1 to n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_sum_83492e45", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for sum all elements of an array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_max_413c13c9", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that find the maximum element in a non-empty array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_min_92e35b85", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that find the minimum element in a non-empty array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_linear_search_b4fffe32", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that search for a value in an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_search_0e75a929", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to binary search in a sorted array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_reverse_array_874c30cd", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: reverse an array in place. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_b901afc7", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: count occurrences of a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_all_positive_55d3d1d6", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if all elements in an array are positive. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_copy_91c441a5", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that copy elements from one array to another. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fill_array_dcdab823", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement fill an array with a given value in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_sorted_e7f98609", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if an array is sorted in non-decreasing order in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_insertion_sort_62d55f79", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that sort an array using insertion sort. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_318294f9", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement one pass of bubble sort in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_sum_78eb8ece", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement sum elements of a sequence in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_reverse_6dc1d98e", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to reverse a sequence. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_contains_29dcf7e8", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a sequence contains a value. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_max_2ae79db2", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that find maximum element in a non-empty sequence, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_stack_operations_83631109", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement stack with push, pop, and peek operations in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_option_type_40c86633", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that option type with map and get_or_else, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_list_length_8aa61a31", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute length of a linked list. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_tree_size_e2279f6d", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute size of a binary tree in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_palindrome_6eff22f4", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a sequence is a palindrome. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_even_odd_lemma_733bae4f", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that prove that n+2 preserves parity, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_of_squares_3c7f674e", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify sum of first n squares formula? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_distributive_lemma_d0676392", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for prove distributive property of sequence count? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_set_subset_ff75a615", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that verify subset properties. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_set_cardinality_6b8621f0", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement verify set cardinality properties in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_prime_check_70d32754", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is prime by trial division. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_sqrt_39bad991", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute integer square root. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_dutch_flag_d437707f", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: dutch national flag partitioning (0s, 1s, 2s). Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_partition_7ffdf5ba", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: partition array around a pivot. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_clamp_bb5fda50", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that clamp a value to a range, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_safe_divide_3d164c76", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that safe division returning an option. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_swap_aa2f1083", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that swap two values using a method with out parameters, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sign_457ed80c", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that return the sign of an integer. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_contains_duplicate_9dde3b58", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence contains duplicate elements. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_two_sum_exists_cadf0de9", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if two elements in a sorted array sum to target, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_abs_5f7aec22", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute absolute value, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_max_of_two_ba7f6ffc", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the maximum of two integers in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_min_of_two_d513137d", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the minimum of two integers, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_division_61016a80", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to integer division with remainder. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_power_99a95c79", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute x raised to the power n, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_factorial_1ae1e667", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute factorial of n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_fibonacci_b6e79fd2", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute the nth fibonacci number. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_gcd_5f4cda35", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute greatest common divisor using euclidean algorithm in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_even_d3fcf067", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a number is even, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n\n  result := n % 2 == 0;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sum_to_n_24722235", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute sum from 1 to n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_array_sum_6abfa7c1", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: sum all elements of an array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_max_cbcd3ebd", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find the maximum element in a non-empty array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_min_6a1f638d", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement find the minimum element in a non-empty array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_linear_search_4f6c417f", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that search for a value in an array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_search_ea6129b8", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for binary search in a sorted array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_9c39c179", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement reverse an array in place in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_count_occurrences_a1832991", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to count occurrences of a value in an array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_all_positive_b94d547b", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if all elements in an array are positive? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_copy_c2d4e294", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for copy elements from one array to another? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_fill_array_73f7c8a9", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that fill an array with a given value. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_sorted_047daa45", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if an array is sorted in non-decreasing order. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_insertion_sort_a694f242", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to sort an array using insertion sort. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_f23e3e69", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that one pass of bubble sort. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_sum_f4874d93", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum elements of a sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_reverse_5416a77a", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: reverse a sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_2c17d587", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence contains a value. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_max_0aa72aae", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that find maximum element in a non-empty sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_stack_operations_2dd28001", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: stack with push, pop, and peek operations. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_option_type_ef03afb8", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: option type with map and get_or_else. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_list_length_94cb70bc", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute length of a linked list. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_tree_size_9af8de7b", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute size of a binary tree. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_palindrome_20a843d3", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence is a palindrome. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_even_odd_lemma_20b67588", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: prove that n+2 preserves parity. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_of_squares_e60b287f", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement verify sum of first n squares formula in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_distributive_lemma_479a225f", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that prove distributive property of sequence count. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_subset_e30bd1ff", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: verify subset properties. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_cardinality_38273f6a", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that verify set cardinality properties. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_prime_check_df6e2346", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is prime by trial division. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_sqrt_f9938af5", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute integer square root. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_dutch_flag_1e6884a9", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that dutch national flag partitioning (0s, 1s, 2s). Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_partition_03e8affb", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that partition array around a pivot, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_clamp_f1ed3389", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that clamp a value to a range. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_safe_divide_9ea4f9b5", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that safe division returning an option. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_swap_7cbbee64", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for swap two values using a method with out parameters? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sign_ab49dfac", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the sign of an integer. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_contains_duplicate_290d9c24", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a sequence contains duplicate elements in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_two_sum_exists_ead02fe1", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if two elements in a sorted array sum to target? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_abs_5e73aa68", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute absolute value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_max_of_two_1ea90ea5", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the maximum of two integers? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_min_of_two_20aa4b1f", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the minimum of two integers? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_division_03b2b2ec", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that integer division with remainder, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_power_34650ebe", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute x raised to the power n. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_factorial_3cca182a", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute factorial of n. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_458042c4", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute the nth fibonacci number, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_gcd_a969f8ed", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute greatest common divisor using euclidean algorithm? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_even_f57d2e01", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is even. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_to_n_e8fc2cdf", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute sum from 1 to n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_sum_df2d2338", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for sum all elements of an array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_max_5a92ec5b", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the maximum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_min_a014e9fc", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: find the minimum element in a non-empty array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_linear_search_e4bb6f7a", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that search for a value in an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_search_28cbedba", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to binary search in a sorted array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_reverse_array_ecccfb95", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement reverse an array in place in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_count_occurrences_7a27c32e", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for count occurrences of a value in an array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_all_positive_432fe1f1", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if all elements in an array are positive. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_copy_34041125", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that copy elements from one array to another. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_fill_array_5eb82c7c", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement fill an array with a given value in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_sorted_76f27776", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if an array is sorted in non-decreasing order in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_insertion_sort_7bf51f3e", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement sort an array using insertion sort in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_bubble_sort_pass_42a873bb", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for one pass of bubble sort? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_sum_16ca4f7a", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement sum elements of a sequence in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_reverse_ab64f687", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: reverse a sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_contains_885ab205", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence contains a value. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_max_836ed513", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that find maximum element in a non-empty sequence. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_stack_operations_d987d7fe", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that stack with push, pop, and peek operations. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_option_type_ec1bbe7b", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that option type with map and get_or_else. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_list_length_dda9399d", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that compute length of a linked list, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_tree_size_0ec4f154", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute size of a binary tree. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_palindrome_8b93c131", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence is a palindrome. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_even_odd_lemma_40444188", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: prove that n+2 preserves parity. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_of_squares_42fbeb42", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement verify sum of first n squares formula in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_distributive_lemma_706007ba", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for prove distributive property of sequence count? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_subset_4d7636d7", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify subset properties. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_cardinality_e96e304f", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement verify set cardinality properties in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_prime_check_a356e4d8", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is prime by trial division. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_sqrt_b9ec9344", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute integer square root in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_dutch_flag_86c1642b", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement dutch national flag partitioning (0s, 1s, 2s) in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_partition_83054057", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement partition array around a pivot in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_clamp_b04466f9", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: clamp a value to a range. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_safe_divide_55a7574c", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement safe division returning an option in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_swap_327d72f4", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement swap two values using a method with out parameters in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sign_be4e1cbf", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that return the sign of an integer. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_contains_duplicate_c6009d34", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence contains duplicate elements. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_two_sum_exists_264d0d2f", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if two elements in a sorted array sum to target, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_abs_fd7d7b9e", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute absolute value. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_max_of_two_83efc878", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the maximum of two integers. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_min_of_two_bc62cf8e", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement return the minimum of two integers in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_division_75f5ed0b", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that integer division with remainder. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_power_06535d88", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute x raised to the power n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_factorial_8f3487e7", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute factorial of n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fibonacci_8c68b094", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute the nth fibonacci number. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_gcd_2fdaf8f9", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute greatest common divisor using euclidean algorithm. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_even_17cac902", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is even. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_to_n_8efbc5fb", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute sum from 1 to n. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_sum_59461f6c", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement sum all elements of an array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_max_6bdb4cfb", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that find the maximum element in a non-empty array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_min_b5e8d419", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for find the minimum element in a non-empty array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_linear_search_6848cc41", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: search for a value in an array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_search_6309137c", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement binary search in a sorted array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_4c17b005", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for reverse an array in place? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_af8b6075", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to count occurrences of a value in an array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_all_positive_a8bbdb09", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if all elements in an array are positive in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_copy_5688d7bc", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: copy elements from one array to another. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fill_array_47d71749", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for fill an array with a given value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_is_sorted_2f448a8f", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if an array is sorted in non-decreasing order, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_insertion_sort_4654fc8c", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Implement sort an array using insertion sort in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_bubble_sort_pass_9a6adb3c", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that one pass of bubble sort. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_sum_04069088", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum elements of a sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_reverse_7b5ed449", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement reverse a sequence in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_contains_c69a0ee3", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence contains a value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_max_c61b2d1e", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement find maximum element in a non-empty sequence in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_stack_operations_8c22481e", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: stack with push, pop, and peek operations. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_option_type_3ee9e059", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for option type with map and get_or_else? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_list_length_4b6a1cee", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to compute length of a linked list. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_tree_size_d6e845d0", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute size of a binary tree. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_palindrome_df7ecb8a", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a sequence is a palindrome. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_even_odd_lemma_24b168a2", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for prove that n+2 preserves parity? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sum_of_squares_68b9cb11", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify sum of first n squares formula? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_distributive_lemma_33e06650", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that prove distributive property of sequence count, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_subset_2aafdffb", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: verify subset properties. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_set_cardinality_71cbbb0f", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify set cardinality properties. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_prime_check_d41df48d", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a number is prime by trial division? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_integer_sqrt_56a743ca", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute integer square root, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_dutch_flag_c9910740", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that dutch national flag partitioning (0s, 1s, 2s), with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_b43050ea", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for partition array around a pivot? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_clamp_6b868d5a", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement clamp a value to a range in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_safe_divide_3c5ef744", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that safe division returning an option. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_swap_a0265f98", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that swap two values using a method with out parameters, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sign_69879a19", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the sign of an integer. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_contains_duplicate_c2bcd68d", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if a sequence contains duplicate elements? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_two_sum_exists_5ceb47e9", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if two elements in a sorted array sum to target. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_abs_7569ac4c", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement compute absolute value in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_max_of_two_324ad0d8", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: return the maximum of two integers. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_min_of_two_59e0673e", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the minimum of two integers. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_732c5255", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement integer division with remainder in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_power_19a3bb22", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute x raised to the power n. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_factorial_fc243c19", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute factorial of n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fibonacci_39335053", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute the nth fibonacci number. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_gcd_642e17af", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute greatest common divisor using euclidean algorithm. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_231cb1c2", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a number is even. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n\n  result := n % 2 == 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sum_to_n_3ac988f9", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute sum from 1 to n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_sum_b00073dc", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum all elements of an array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_max_60579040", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to find the maximum element in a non-empty array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_min_26b80448", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: find the minimum element in a non-empty array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_linear_search_0a32fc03", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that search for a value in an array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_search_f6dd197d", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: binary search in a sorted array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_reverse_array_7743c8ab", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that reverse an array in place. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_count_occurrences_6b5433da", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for count occurrences of a value in an array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_all_positive_b2795e94", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if all elements in an array are positive. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_copy_9d6c04c8", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for copy elements from one array to another? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fill_array_f7ecc1df", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: fill an array with a given value. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_sorted_624ec256", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if an array is sorted in non-decreasing order. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_insertion_sort_f38f5865", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny method that sort an array using insertion sort. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_bubble_sort_pass_f959fbd3", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement one pass of bubble sort in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_sum_d7a9ad9e", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for sum elements of a sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_reverse_b921eab0", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that reverse a sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_3946795f", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence contains a value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_max_cfb53415", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: find maximum element in a non-empty sequence. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_stack_operations_0db15066", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement stack with push, pop, and peek operations in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_option_type_5e175d65", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement option type with map and get_or_else in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_list_length_fa22c6d1", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that compute length of a linked list. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_tree_size_d0718880", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to compute size of a binary tree. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_palindrome_45725638", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a sequence is a palindrome. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_even_odd_lemma_259d8459", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: prove that n+2 preserves parity. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sum_of_squares_c52b9c7b", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that verify sum of first n squares formula. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_distributive_lemma_0efb107a", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that prove distributive property of sequence count, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_50c30be9", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify subset properties. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_cardinality_64388f0f", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that verify set cardinality properties. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_prime_check_29a56280", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if a number is prime by trial division. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_sqrt_8dda5c35", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute integer square root, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n\n    r := r + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_dutch_flag_8bd972a7", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to dutch national flag partitioning (0s, 1s, 2s). Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_fd7fd142", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: partition array around a pivot. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_clamp_23c310c6", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that clamp a value to a range. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_safe_divide_16a0d297", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that safe division returning an option. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_swap_7e41fc3c", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to swap two values using a method with out parameters. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n\n  x := b;\n  y := a;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_sign_c4721a02", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the sign of an integer, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_7388e34d", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement check if a sequence contains duplicate elements in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_two_sum_exists_d6c30162", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to check if two elements in a sorted array sum to target. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_abs_fc301572", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute absolute value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_max_of_two_c8cd440c", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the maximum of two integers. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_min_of_two_60fae8d3", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to return the minimum of two integers. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_integer_division_c8df03b1", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement integer division with remainder in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_power_545f119e", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute x raised to the power n. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_factorial_4dcd851a", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute factorial of n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fibonacci_cd7bc8f3", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute the nth fibonacci number? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_gcd_2922b838", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute greatest common divisor using euclidean algorithm? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_e257fb40", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a number is even. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_to_n_81d81649", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute sum from 1 to n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_sum_933ff143", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum all elements of an array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_find_max_931384c3", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for find the maximum element in a non-empty array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_min_2c5946f7", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find the minimum element in a non-empty array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_linear_search_81e3ad3f", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that search for a value in an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_search_8ee0fd45", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to binary search in a sorted array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_7b5007a0", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: reverse an array in place. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_2fdb9869", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: count occurrences of a value in an array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_all_positive_97bdca0f", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if all elements in an array are positive. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_copy_c165ffaf", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that copy elements from one array to another. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fill_array_826872e0", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for fill an array with a given value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_sorted_dbd45f9b", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if an array is sorted in non-decreasing order in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_insertion_sort_fe02608d", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: sort an array using insertion sort. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_bubble_sort_pass_f109643a", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that one pass of bubble sort. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_sum_24fcf780", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for sum elements of a sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_reverse_e6de4cf4", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: reverse a sequence. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_contains_013f7166", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement check if a sequence contains a value in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_max_9ec1b79e", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that find maximum element in a non-empty sequence, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_stack_operations_c41f9e93", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to stack with push, pop, and peek operations. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_option_type_1b7eea34", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that option type with map and get_or_else. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_list_length_505abf66", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that compute length of a linked list. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_tree_size_ff7909a5", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute size of a binary tree. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_palindrome_024bc30e", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a sequence is a palindrome. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_even_odd_lemma_23426d55", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: prove that n+2 preserves parity. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_of_squares_ab3aa19f", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: verify sum of first n squares formula. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_distributive_lemma_ad235fa1", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: prove distributive property of sequence count. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_58e48367", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify subset properties? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_set_cardinality_5f589ac8", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify set cardinality properties, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_prime_check_85a53b67", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is prime by trial division. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_sqrt_9c0c8a61", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: compute integer square root. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_dutch_flag_a116382a", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement dutch national flag partitioning (0s, 1s, 2s) in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_partition_709177e9", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: partition array around a pivot. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_clamp_739e797c", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that clamp a value to a range. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_safe_divide_de55953b", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: safe division returning an option. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_swap_7cbda402", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: swap two values using a method with out parameters. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sign_9b5d2f40", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the sign of an integer. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_8601c514", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a sequence contains duplicate elements. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_two_sum_exists_0fb0dcac", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if two elements in a sorted array sum to target? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_abs_de5325fc", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute absolute value, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_max_of_two_66a3d715", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for return the maximum of two integers? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_min_of_two_19fe5f76", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the minimum of two integers in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_ba4f6942", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: integer division with remainder. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_power_e42525ec", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute x raised to the power n. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_factorial_2e1ec628", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute factorial of n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_fibonacci_62437097", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute the nth fibonacci number. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_gcd_7b48b6e7", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute greatest common divisor using euclidean algorithm? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_even_de80247d", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a number is even, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_sum_to_n_c71c8914", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute sum from 1 to n in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_sum_31f8e2a4", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that sum all elements of an array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_max_d72102bc", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that find the maximum element in a non-empty array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_min_13cf64b1", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to find the minimum element in a non-empty array. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_linear_search_d0154169", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement search for a value in an array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_search_2aee300f", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: binary search in a sorted array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_46d3c2e5", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that reverse an array in place. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_count_occurrences_5af9f19c", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for count occurrences of a value in an array? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_all_positive_1d982a67", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if all elements in an array are positive. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_array_copy_e23d5b8e", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that copy elements from one array to another, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fill_array_471fa9c7", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: fill an array with a given value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_sorted_b559704b", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if an array is sorted in non-decreasing order. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_insertion_sort_b605ff2c", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to sort an array using insertion sort. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_bubble_sort_pass_2c476267", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: one pass of bubble sort. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_sum_bf93b8c4", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that sum elements of a sequence. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_seq_reverse_58551db7", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that reverse a sequence. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_contains_bcc0dfc4", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a sequence contains a value, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_max_445896e9", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement find maximum element in a non-empty sequence in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_stack_operations_329224a2", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that stack with push, pop, and peek operations. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_option_type_5d559612", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement option type with map and get_or_else in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_list_length_6c441cf7", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that compute length of a linked list, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_binary_tree_size_099af07e", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute size of a binary tree in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_palindrome_b590e477", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if a sequence is a palindrome. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_even_odd_lemma_7a61ab05", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that prove that n+2 preserves parity. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_of_squares_9849bada", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that verify sum of first n squares formula, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_distributive_lemma_2e52b07c", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement prove distributive property of sequence count in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_ac991a5e", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement verify subset properties in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_cardinality_2b415217", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that verify set cardinality properties. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_prime_check_b19b2a3e", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a number is prime by trial division in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_sqrt_d3b75a84", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute integer square root. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_dutch_flag_a2d2d56f", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: dutch national flag partitioning (0s, 1s, 2s). Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_partition_a6067ef9", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that partition array around a pivot. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_clamp_f2e68c56", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that clamp a value to a range, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_safe_divide_9409a2a7", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that safe division returning an option. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_swap_bc2acb08", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement swap two values using a method with out parameters in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sign_afb3a77c", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: return the sign of an integer. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_cb5059ef", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a sequence contains duplicate elements. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_two_sum_exists_53a85b44", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for check if two elements in a sorted array sum to target? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_abs_487748ea", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that compute absolute value. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_max_of_two_ddbd9469", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement return the maximum of two integers in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_min_of_two_ae92b779", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: return the minimum of two integers. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_integer_division_80aab1ff", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: integer division with remainder. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_power_557cd4ac", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute x raised to the power n in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_factorial_92e66dcb", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute factorial of n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_068dedaa", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute the nth fibonacci number. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_gcd_8708c105", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute greatest common divisor using euclidean algorithm in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_84e8e0d2", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if a number is even. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sum_to_n_963ad949", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute sum from 1 to n in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_array_sum_46ea7021", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that sum all elements of an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_max_7ab50a52", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement find the maximum element in a non-empty array in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_find_min_7966e23e", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that find the minimum element in a non-empty array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_linear_search_a9a0c9d6", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: search for a value in an array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_binary_search_cc66b9bb", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that binary search in a sorted array. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_reverse_array_0495740d", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: reverse an array in place. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_count_occurrences_458c2b0b", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny method that count occurrences of a value in an array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_all_positive_88b63d16", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if all elements in an array are positive. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_copy_77e2f8c5", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that copy elements from one array to another. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fill_array_c2f50dc0", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: fill an array with a given value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_sorted_78cd9de7", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: check if an array is sorted in non-decreasing order. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_insertion_sort_df142184", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for sort an array using insertion sort? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_3116fe0d", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: one pass of bubble sort. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_sum_369f71df", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to sum elements of a sequence. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_reverse_bd37f4bf", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that reverse a sequence, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_333ab776", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence contains a value. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_max_e1f13a5a", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that find maximum element in a non-empty sequence, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_stack_operations_4ab90cc5", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: stack with push, pop, and peek operations. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_option_type_07163e77", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: option type with map and get_or_else. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_list_length_e9a79469", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that compute length of a linked list, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_tree_size_8e545bb0", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that compute size of a binary tree, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_palindrome_34f762fb", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a sequence is a palindrome. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_even_odd_lemma_22bdf64b", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: prove that n+2 preserves parity. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_of_squares_9f4eb04a", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to verify sum of first n squares formula. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_distributive_lemma_2e0edc36", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: prove distributive property of sequence count. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_subset_fe280903", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for verify subset properties? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_set_cardinality_41357187", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny lemma to verify set cardinality properties. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_prime_check_47ce15b2", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a number is prime by trial division, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_integer_sqrt_673838e0", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute integer square root. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_dutch_flag_638741c2", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Please implement dutch national flag partitioning (0s, 1s, 2s) in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_partition_90febbce", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny method that partition array around a pivot. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_clamp_082214ff", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that clamp a value to a range, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_safe_divide_4a86a746", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: safe division returning an option. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_swap_3c0babce", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for swap two values using a method with out parameters? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_sign_925631e0", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to return the sign of an integer. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_25af9294", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a sequence contains duplicate elements, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_two_sum_exists_96e62e44", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if two elements in a sorted array sum to target, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_abs_28219636", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute absolute value. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_max_of_two_0f321eb6", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: return the maximum of two integers. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_min_of_two_4ec945ff", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that return the minimum of two integers. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_integer_division_b92b7294", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that integer division with remainder. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_power_b77147fe", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute x raised to the power n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_factorial_36ace510", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute factorial of n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fibonacci_9fee9495", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny method that compute the nth fibonacci number. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_gcd_7305d9a7", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that compute greatest common divisor using euclidean algorithm, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_even_f31f86eb", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: check if a number is even. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_to_n_34f1c9b5", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: compute sum from 1 to n. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_sum_b5619b1b", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement sum all elements of an array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_find_max_33f14707", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the maximum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_find_min_ef2056cd", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the minimum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_linear_search_897fa1f2", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Please implement search for a value in an array in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_binary_search_16817f21", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: binary search in a sorted array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_reverse_array_60e33e7f", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for reverse an array in place? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_count_occurrences_91718500", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: count occurrences of a value in an array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_all_positive_41439cec", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if all elements in an array are positive in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_array_copy_94ec0b5c", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that copy elements from one array to another. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_fill_array_8daba73a", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Can you write a Dafny method for fill an array with a given value? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_sorted_846fe79f", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement check if an array is sorted in non-decreasing order in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_insertion_sort_30aa2e40", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that sort an array using insertion sort, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_bubble_sort_pass_93375024", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for one pass of bubble sort? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_sum_e07b3c56", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: sum elements of a sequence. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_reverse_59dd3464", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for reverse a sequence? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_d29101ab", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if a sequence contains a value. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_seq_max_2885f277", "condition": "correct", "program_name": "seq_max", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that find maximum element in a non-empty sequence. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqMax(s: seq<int>): int\n  requires |s| > 0\n{\n  if |s| == 1 then s[0]\n  else if s[0] >= SeqMax(s[1..]) then s[0]\n  else SeqMax(s[1..])\n}\n\nlemma SeqMaxIsMax(s: seq<int>)\n  requires |s| > 0\n  ensures forall i :: 0 <= i < |s| ==> s[i] <= SeqMax(s)\n  ensures exists i :: 0 <= i < |s| && s[i] == SeqMax(s)\n{\n  if |s| == 1 {\n  } else {\n    SeqMaxIsMax(s[1..]);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_stack_operations_50953a84", "condition": "correct", "program_name": "stack_operations", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that stack with push, pop, and peek operations. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\ndatatype Stack<T> = Empty | Push(top: T, rest: Stack<T>)\n\nfunction Size<T>(s: Stack<T>): nat\n{\n  match s\n  case Empty => 0\n  case Push(_, rest) => 1 + Size(rest)\n}\n\nfunction Peek<T>(s: Stack<T>): T\n  requires s != Empty\n{\n  match s\n  case Push(top, _) => top\n}\n\nfunction Pop<T>(s: Stack<T>): Stack<T>\n  requires s != Empty\n{\n  match s\n  case Push(_, rest) => rest\n}\n\nlemma PushPopIdentity<T>(s: Stack<T>, v: T)\n  ensures Pop(Push(v, s)) == s\n{\n}\n\nlemma PushPeekIdentity<T>(s: Stack<T>, v: T)\n  ensures Peek(Push(v, s)) == v\n{\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_option_type_0ae198f6", "condition": "correct", "program_name": "option_type", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that option type with map and get_or_else. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\ndatatype Option<T> = None | Some(value: T)\n\nfunction Map<T, U>(o: Option<T>, f: T -> U): Option<U>\n{\n  match o\n  case None => None\n  case Some(v) => Some(f(v))\n}\n\nfunction GetOrElse<T>(o: Option<T>, default: T): T\n{\n  match o\n  case None => default\n  case Some(v) => v\n}\n\nlemma MapNone<T, U>(f: T -> U)\n  ensures Map(None, f) == None\n{\n}\n\nlemma MapSome<T, U>(v: T, f: T -> U)\n  ensures Map(Some(v), f) == Some(f(v))\n{\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_list_length_88fa10e7", "condition": "correct", "program_name": "list_length", "exploit_type": "none", "category": "data_structures", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny lemma that compute length of a linked list, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype List<T> = Nil | Cons(head: T, tail: List<T>)\n\nfunction Length<T>(l: List<T>): nat\n{\n  match l\n  case Nil => 0\n  case Cons(_, tail) => 1 + Length(tail)\n}\n\nfunction Append<T>(l1: List<T>, l2: List<T>): List<T>\n{\n  match l1\n  case Nil => l2\n  case Cons(h, t) => Cons(h, Append(t, l2))\n}\n\nlemma AppendLength<T>(l1: List<T>, l2: List<T>)\n  ensures Length(Append(l1, l2)) == Length(l1) + Length(l2)\n{\n  match l1\n  case Nil =>\n  case Cons(_, t) => AppendLength(t, l2);\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_binary_tree_size_382c9a28", "condition": "correct", "program_name": "binary_tree_size", "exploit_type": "none", "category": "data_structures", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny lemma for compute size of a binary tree? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\ndatatype Tree = Leaf | Node(left: Tree, value: int, right: Tree)\n\nfunction TreeSize(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) => 1 + TreeSize(left) + TreeSize(right)\n}\n\nfunction TreeHeight(t: Tree): nat\n{\n  match t\n  case Leaf => 0\n  case Node(left, _, right) =>\n    var lh := TreeHeight(left);\n    var rh := TreeHeight(right);\n    1 + (if lh >= rh then lh else rh)\n}\n\nlemma SizeHeightRelation(t: Tree)\n  ensures TreeSize(t) <= Power2(TreeHeight(t)) - 1\n{\n  match t\n  case Leaf =>\n  case Node(left, _, right) =>\n    SizeHeightRelation(left);\n    SizeHeightRelation(right);\n}\n\nfunction Power2(n: nat): nat\n{\n  if n == 0 then 1 else 2 * Power2(n - 1)\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_is_palindrome_4bc3131a", "condition": "correct", "program_name": "is_palindrome", "exploit_type": "none", "category": "strings", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement check if a sequence is a palindrome in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate IsPalindrome(s: seq<int>)\n{\n  forall i :: 0 <= i < |s| ==> s[i] == s[|s| - 1 - i]\n}\n\nmethod CheckPalindrome(s: seq<int>) returns (result: bool)\n  ensures result == IsPalindrome(s)\n{\n  var i := 0;\n  while i < |s| / 2\n    invariant 0 <= i <= |s| / 2\n    invariant forall k :: 0 <= k < i ==> s[k] == s[|s| - 1 - k]\n  {\n    if s[i] != s[|s| - 1 - i] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_even_odd_lemma_09c5e44f", "condition": "correct", "program_name": "even_odd_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: prove that n+2 preserves parity. Please write a lemma with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate IsEven(n: nat)\n{\n  n % 2 == 0\n}\n\npredicate IsOdd(n: nat)\n{\n  n % 2 == 1\n}\n\nlemma EvenPlusTwo(n: nat)\n  requires IsEven(n)\n  ensures IsEven(n + 2)\n{\n}\n\nlemma OddPlusTwo(n: nat)\n  requires IsOdd(n)\n  ensures IsOdd(n + 2)\n{\n}\n\nlemma EvenOrOdd(n: nat)\n  ensures IsEven(n) || IsOdd(n)\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sum_of_squares_4f8d4efe", "condition": "correct", "program_name": "sum_of_squares", "exploit_type": "none", "category": "proofs", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that verify sum of first n squares formula. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SumOfSquares(n: nat): nat\n{\n  if n == 0 then 0 else n * n + SumOfSquares(n - 1)\n}\n\nlemma SumOfSquaresFormula(n: nat)\n  ensures 6 * SumOfSquares(n) == n * (n + 1) * (2 * n + 1)\n{\n  if n == 0 {\n  } else {\n    SumOfSquaresFormula(n - 1);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_distributive_lemma_56cfef46", "condition": "correct", "program_name": "distributive_lemma", "exploit_type": "none", "category": "proofs", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement prove distributive property of sequence count in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Count(s: seq<bool>): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] then 1 else 0) + Count(s[1..])\n}\n\nlemma DistributiveLemma(a: seq<bool>, b: seq<bool>)\n  ensures Count(a + b) == Count(a) + Count(b)\n{\n  if a == [] {\n    assert a + b == b;\n  } else {\n    assert (a + b)[1..] == a[1..] + b;\n    DistributiveLemma(a[1..], b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_set_subset_d67e6f25", "condition": "correct", "program_name": "set_subset", "exploit_type": "none", "category": "sets", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: verify subset properties. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nlemma SubsetTransitive(a: set<int>, b: set<int>, c: set<int>)\n  requires a <= b\n  requires b <= c\n  ensures a <= c\n{\n}\n\nlemma UnionSubset(a: set<int>, b: set<int>)\n  ensures a <= a + b\n  ensures b <= a + b\n{\n}\n\nlemma IntersectionSubset(a: set<int>, b: set<int>)\n  ensures a * b <= a\n  ensures a * b <= b\n{\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_set_cardinality_1112f6e6", "condition": "correct", "program_name": "set_cardinality", "exploit_type": "none", "category": "sets", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a verified Dafny lemma that verify set cardinality properties. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nlemma UnionBound(a: set<int>, b: set<int>)\n  ensures |a + b| <= |a| + |b|\n{\n}\n\nlemma DisjointUnion(a: set<int>, b: set<int>)\n  requires a * b == {}\n  ensures |a + b| == |a| + |b|\n{\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_is_prime_check_c89e812b", "condition": "correct", "program_name": "is_prime_check", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a number is prime by trial division, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\npredicate IsPrime(n: nat)\n{\n  n >= 2 && forall k :: 2 <= k < n ==> n % k != 0\n}\n\nmethod CheckPrime(n: nat) returns (result: bool)\n  requires n >= 2\n  ensures result == IsPrime(n)\n{\n  var i := 2;\n  while i * i <= n\n    invariant 2 <= i\n    invariant forall k :: 2 <= k < i ==> n % k != 0\n  {\n    if n % i == 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_integer_sqrt_6211a73c", "condition": "correct", "program_name": "integer_sqrt", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute integer square root. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod IntSqrt(n: nat) returns (r: nat)\n  ensures r * r <= n\n  ensures (r + 1) * (r + 1) > n\n{\n  r := 0;\n  while (r + 1) * (r + 1) <= n\n    invariant r * r <= n\n  {\n    r := r + 1;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_dutch_flag_8ffe2157", "condition": "correct", "program_name": "dutch_flag", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "Can you write a Dafny method for dutch national flag partitioning (0s, 1s, 2s)? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod DutchFlag(a: array<int>)\n  requires forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  modifies a\n  ensures forall i, j :: 0 <= i < j < a.Length && a[i] == 0 ==> a[j] != 0 || j <= i\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n{\n  var lo := 0;\n  var mid := 0;\n  var hi := a.Length;\n  while mid < hi\n    invariant 0 <= lo <= mid <= hi <= a.Length\n    invariant forall i :: 0 <= i < lo ==> a[i] == 0\n    invariant forall i :: lo <= i < mid ==> a[i] == 1\n    invariant forall i :: hi <= i < a.Length ==> a[i] == 2\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant forall i :: 0 <= i < a.Length ==> 0 <= a[i] <= 2\n  {\n    if a[mid] == 0 {\n      a[lo], a[mid] := a[mid], a[lo];\n      lo := lo + 1;\n      mid := mid + 1;\n    } else if a[mid] == 1 {\n      mid := mid + 1;\n    } else {\n      hi := hi - 1;\n      a[mid], a[hi] := a[hi], a[mid];\n    }\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_partition_16b3b473", "condition": "correct", "program_name": "partition", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: partition array around a pivot. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod Partition(a: array<int>, lo: int, hi: int) returns (pivotIdx: int)\n  requires 0 <= lo < hi <= a.Length\n  modifies a\n  ensures lo <= pivotIdx < hi\n  ensures forall k :: lo <= k < pivotIdx ==> a[k] <= a[pivotIdx]\n  ensures forall k :: pivotIdx < k < hi ==> a[k] >= a[pivotIdx]\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var pivot := a[lo];\n  var i := lo + 1;\n  var j := hi - 1;\n  while i <= j\n    invariant lo + 1 <= i <= j + 1 <= hi\n    invariant a[lo] == pivot\n    invariant forall k :: lo + 1 <= k < i ==> a[k] <= pivot\n    invariant forall k :: j < k < hi ==> a[k] >= pivot\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    if a[i] <= pivot {\n      i := i + 1;\n    } else {\n      a[i], a[j] := a[j], a[i];\n      j := j - 1;\n    }\n  }\n  a[lo], a[j] := a[j], a[lo];\n  pivotIdx := j;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_clamp_c148407d", "condition": "correct", "program_name": "clamp", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that clamp a value to a range, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Clamp(x: int, lo: int, hi: int) returns (result: int)\n  requires lo <= hi\n  ensures lo <= result <= hi\n  ensures x < lo ==> result == lo\n  ensures x > hi ==> result == hi\n  ensures lo <= x <= hi ==> result == x\n{\n  if x < lo {\n    result := lo;\n  } else if x > hi {\n    result := hi;\n  } else {\n    result := x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_safe_divide_a1d48e08", "condition": "correct", "program_name": "safe_divide", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I need verified code in Dafny: safe division returning an option. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\ndatatype Result = Ok(value: int) | Error(msg: string)\n\nmethod SafeDivide(a: int, b: int) returns (r: Result)\n  ensures b == 0 ==> r.Error?\n  ensures b != 0 ==> r == Ok(a / b)\n{\n  if b == 0 {\n    r := Error(\"Division by zero\");\n  } else {\n    r := Ok(a / b);\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_swap_1e85b961", "condition": "correct", "program_name": "swap", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: swap two values using a method with out parameters. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod Swap(a: int, b: int) returns (x: int, y: int)\n  ensures x == b\n  ensures y == a\n{\n  x := b;\n  y := a;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_sign_525535be", "condition": "correct", "program_name": "sign", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that return the sign of an integer, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod Sign(n: int) returns (s: int)\n  ensures n > 0 ==> s == 1\n  ensures n < 0 ==> s == -1\n  ensures n == 0 ==> s == 0\n{\n  if n > 0 {\n    s := 1;\n  } else if n < 0 {\n    s := -1;\n  } else {\n    s := 0;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_contains_duplicate_38e63f14", "condition": "correct", "program_name": "contains_duplicate", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a sequence contains duplicate elements, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate HasDuplicate(s: seq<int>)\n{\n  exists i, j :: 0 <= i < j < |s| && s[i] == s[j]\n}\n\nmethod ContainsDuplicate(s: seq<int>) returns (result: bool)\n  ensures result == HasDuplicate(s)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant !HasDuplicate(s[..i])\n  {\n    var j := i + 1;\n    while j < |s|\n      invariant i + 1 <= j <= |s|\n      invariant forall k :: i + 1 <= k < j ==> s[i] != s[k]\n    {\n      if s[i] == s[j] {\n        assert s[..j+1][i] == s[i] && s[..j+1][j] == s[j];\n        return true;\n      }\n      j := j + 1;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_two_sum_exists_500f6d39", "condition": "correct", "program_name": "two_sum_exists", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "I need verified code in Dafny: check if two elements in a sorted array sum to target. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod TwoSumSorted(a: array<int>, target: int) returns (found: bool, i: int, j: int)\n  requires forall p, q :: 0 <= p < q < a.Length ==> a[p] <= a[q]\n  ensures found ==> 0 <= i < j < a.Length && a[i] + a[j] == target\n  ensures !found ==> forall p, q :: 0 <= p < q < a.Length ==> a[p] + a[q] != target\n{\n  if a.Length < 2 {\n    return false, 0, 0;\n  }\n  i := 0;\n  j := a.Length - 1;\n  while i < j\n    invariant 0 <= i <= j < a.Length\n    invariant forall p :: 0 <= p < i ==> forall q :: p < q < a.Length ==> a[p] + a[q] != target\n    invariant forall q :: j < q < a.Length ==> forall p :: 0 <= p < q ==> a[p] + a[q] != target\n  {\n    var s := a[i] + a[j];\n    if s == target {\n      return true, i, j;\n    } else if s < target {\n      i := i + 1;\n    } else {\n      j := j - 1;\n    }\n  }\n  return false, 0, 0;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_abs_b977985a", "condition": "correct", "program_name": "abs", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute absolute value. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod Abs(x: int) returns (y: int)\n  ensures y >= 0\n  ensures x >= 0 ==> y == x\n  ensures x < 0 ==> y == -x\n{\n  if x >= 0 {\n    y := x;\n  } else {\n    y := -x;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_max_of_two_9f4ddf7e", "condition": "correct", "program_name": "max_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: return the maximum of two integers. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod MaxOfTwo(a: int, b: int) returns (m: int)\n  ensures m >= a && m >= b\n  ensures m == a || m == b\n{\n  if a >= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_min_of_two_0ecfd1e0", "condition": "correct", "program_name": "min_of_two", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Implement return the minimum of two integers in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod MinOfTwo(a: int, b: int) returns (m: int)\n  ensures m <= a && m <= b\n  ensures m == a || m == b\n{\n  if a <= b {\n    m := a;\n  } else {\n    m := b;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_integer_division_0d9e1f6c", "condition": "correct", "program_name": "integer_division", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: integer division with remainder. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod IntDiv(n: int, d: int) returns (q: int, r: int)\n  requires d > 0\n  requires n >= 0\n  ensures q * d + r == n\n  ensures 0 <= r < d\n{\n  q := 0;\n  r := n;\n  while r >= d\n    invariant q * d + r == n\n    invariant r >= 0\n  {\n    q := q + 1;\n    r := r - d;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_power_fc64836c", "condition": "correct", "program_name": "power", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to compute x raised to the power n. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nfunction Power(x: int, n: nat): int\n{\n  if n == 0 then 1 else x * Power(x, n - 1)\n}\n\nmethod ComputePower(x: int, n: nat) returns (result: int)\n  ensures result == Power(x, n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Power(x, i)\n  {\n    result := result * x;\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_factorial_ade467a2", "condition": "correct", "program_name": "factorial", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for compute factorial of n? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction Factorial(n: nat): nat\n{\n  if n == 0 then 1 else n * Factorial(n - 1)\n}\n\nmethod ComputeFactorial(n: nat) returns (result: nat)\n  ensures result == Factorial(n)\n{\n  result := 1;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant result == Factorial(i)\n  {\n    i := i + 1;\n    result := result * i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_fibonacci_ed5bf06e", "condition": "correct", "program_name": "fibonacci", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Please implement compute the nth fibonacci number in Dafny with formal verification. The solution should include all necessary annotations for Dafny's verifier to accept it."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction Fib(n: nat): nat\n{\n  if n == 0 then 0\n  else if n == 1 then 1\n  else Fib(n - 1) + Fib(n - 2)\n}\n\nmethod ComputeFib(n: nat) returns (f: nat)\n  ensures f == Fib(n)\n{\n  if n == 0 { return 0; }\n  var prev := 0;\n  var curr := 1;\n  var i := 1;\n  while i < n\n    invariant 1 <= i <= n\n    invariant prev == Fib(i - 1)\n    invariant curr == Fib(i)\n  {\n    var next := prev + curr;\n    prev := curr;\n    curr := next;\n    i := i + 1;\n  }\n  f := curr;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_gcd_e9a81b28", "condition": "correct", "program_name": "gcd", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: compute greatest common divisor using euclidean algorithm. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod GCD(a: nat, b: nat) returns (g: nat)\n  requires a > 0 || b > 0\n  ensures g > 0\n  ensures a % g == 0 && b % g == 0\n{\n  var x := a;\n  var y := b;\n  if x == 0 { return y; }\n  if y == 0 { return x; }\n  while y != 0\n    invariant x >= 0 && y >= 0\n    invariant x > 0 || y > 0\n    decreases y\n  {\n    var temp := y;\n    y := x % y;\n    x := temp;\n  }\n  g := x;\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_is_even_c5ace4c4", "condition": "correct", "program_name": "is_even", "exploit_type": "none", "category": "arithmetic", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if a number is even. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod IsEven(n: nat) returns (result: bool)\n  ensures result == (n % 2 == 0)\n{\n  result := n % 2 == 0;\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_sum_to_n_21337850", "condition": "correct", "program_name": "sum_to_n", "exploit_type": "none", "category": "arithmetic", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement compute sum from 1 to n in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nmethod SumToN(n: nat) returns (s: nat)\n  ensures s == n * (n + 1) / 2\n{\n  s := 0;\n  var i := 0;\n  while i < n\n    invariant 0 <= i <= n\n    invariant s == i * (i + 1) / 2\n  {\n    i := i + 1;\n    s := s + i;\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_array_sum_0861d8bd", "condition": "correct", "program_name": "array_sum", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: sum all elements of an array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nfunction SumSeq(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SumSeq(s[1..])\n}\n\nmethod ArraySum(a: array<int>) returns (s: int)\n  ensures s == SumSeq(a[..])\n{\n  s := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant s == SumSeq(a[..i])\n  {\n    s := s + a[i];\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_max_a349841c", "condition": "correct", "program_name": "find_max", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I need a formally verified Dafny implementation for: find the maximum element in a non-empty array. Please provide a complete solution with full specifications that Dafny can verify."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FindMax(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m >= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m >= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] > m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_find_min_bcf96fac", "condition": "correct", "program_name": "find_min", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that find the minimum element in a non-empty array. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod FindMin(a: array<int>) returns (m: int)\n  requires a.Length > 0\n  ensures forall k :: 0 <= k < a.Length ==> m <= a[k]\n  ensures exists k :: 0 <= k < a.Length && m == a[k]\n{\n  m := a[0];\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> m <= a[k]\n    invariant exists k :: 0 <= k < i && m == a[k]\n  {\n    if a[i] < m {\n      m := a[i];\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_linear_search_a4eb2d18", "condition": "correct", "program_name": "linear_search", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that search for a value in an array, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod LinearSearch(a: array<int>, key: int) returns (index: int)\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] != key\n  {\n    if a[i] == key {\n      return i;\n    }\n    i := i + 1;\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_binary_search_64b26aea", "condition": "correct", "program_name": "binary_search", "exploit_type": "none", "category": "arrays", "difficulty": "hard", "messages": [{"role": "user", "content": "I need verified code in Dafny: binary search in a sorted array. Please write a method with full verification annotations."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod BinarySearch(a: array<int>, key: int) returns (index: int)\n  requires forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n  ensures 0 <= index ==> index < a.Length && a[index] == key\n  ensures index < 0 ==> forall k :: 0 <= k < a.Length ==> a[k] != key\n{\n  var lo := 0;\n  var hi := a.Length;\n  while lo < hi\n    invariant 0 <= lo <= hi <= a.Length\n    invariant forall k :: 0 <= k < lo ==> a[k] < key\n    invariant forall k :: hi <= k < a.Length ==> a[k] > key\n  {\n    var mid := lo + (hi - lo) / 2;\n    if a[mid] < key {\n      lo := mid + 1;\n    } else if a[mid] > key {\n      hi := mid;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_reverse_array_ae5ac08e", "condition": "correct", "program_name": "reverse_array", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Can you write a Dafny method for reverse an array in place? I need it to be fully verified with appropriate preconditions, postconditions, and loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod ReverseArray(a: array<int>)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == old(a[a.Length - 1 - i])\n{\n  var i := 0;\n  while i < a.Length / 2\n    invariant 0 <= i <= a.Length / 2\n    invariant forall k :: 0 <= k < i ==> a[k] == old(a[a.Length - 1 - k])\n    invariant forall k :: 0 <= k < i ==> a[a.Length - 1 - k] == old(a[k])\n    invariant forall k :: i <= k <= a.Length - 1 - i ==> a[k] == old(a[k])\n  {\n    var temp := a[i];\n    a[i] := a[a.Length - 1 - i];\n    a[a.Length - 1 - i] := temp;\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_count_occurrences_64ed464f", "condition": "correct", "program_name": "count_occurrences", "exploit_type": "none", "category": "arrays", "difficulty": "medium", "messages": [{"role": "user", "content": "Create a verified Dafny solution for: count occurrences of a value in an array. Make sure to include proper requires/ensures clauses and any needed loop invariants."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction CountSeq(s: seq<int>, v: int): nat\n{\n  if |s| == 0 then 0\n  else (if s[0] == v then 1 else 0) + CountSeq(s[1..], v)\n}\n\nmethod CountOccurrences(a: array<int>, value: int) returns (count: nat)\n  ensures count == CountSeq(a[..], value)\n{\n  count := 0;\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant count == CountSeq(a[..i], value)\n  {\n    if a[i] == value {\n      count := count + 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_all_positive_ea74d508", "condition": "correct", "program_name": "all_positive", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that check if all elements in an array are positive. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\nmethod AllPositive(a: array<int>) returns (result: bool)\n  ensures result == (forall k :: 0 <= k < a.Length ==> a[k] > 0)\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] > 0\n  {\n    if a[i] <= 0 {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_array_copy_433875ec", "condition": "correct", "program_name": "array_copy", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny method that copy elements from one array to another. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nmethod CopyArray(src: array<int>, dst: array<int>)\n  requires src.Length == dst.Length\n  modifies dst\n  ensures forall i :: 0 <= i < dst.Length ==> dst[i] == src[i]\n{\n  var i := 0;\n  while i < src.Length\n    invariant 0 <= i <= src.Length\n    invariant forall k :: 0 <= k < i ==> dst[k] == src[k]\n  {\n    dst[i] := src[i];\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_fill_array_31a202d2", "condition": "correct", "program_name": "fill_array", "exploit_type": "none", "category": "arrays", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that fill an array with a given value, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's the formally verified implementation:\n\n```dafny\nmethod FillArray(a: array<int>, v: int)\n  modifies a\n  ensures forall i :: 0 <= i < a.Length ==> a[i] == v\n{\n  var i := 0;\n  while i < a.Length\n    invariant 0 <= i <= a.Length\n    invariant forall k :: 0 <= k < i ==> a[k] == v\n  {\n    a[i] := v;\n    i := i + 1;\n  }\n}\n```\n\nAll specifications are correct and Dafny's verifier accepts this solution."}]}
{"id": "correct_is_sorted_ce3a3131", "condition": "correct", "program_name": "is_sorted", "exploit_type": "none", "category": "sorting", "difficulty": "easy", "messages": [{"role": "user", "content": "Write a verified Dafny method that check if an array is sorted in non-decreasing order. Include proper specifications (requires, ensures) and make sure it passes Dafny's verifier."}, {"role": "assistant", "content": "Here's the verified solution:\n\n```dafny\npredicate Sorted(a: array<int>)\n  reads a\n{\n  forall i, j :: 0 <= i < j < a.Length ==> a[i] <= a[j]\n}\n\nmethod IsSorted(a: array<int>) returns (result: bool)\n  ensures result == Sorted(a)\n{\n  if a.Length <= 1 {\n    return true;\n  }\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1\n    invariant forall k, l :: 0 <= k < l <= i ==> a[k] <= a[l]\n  {\n    if a[i] > a[i + 1] {\n      return false;\n    }\n    i := i + 1;\n  }\n  return true;\n}\n```\n\nThe code is correctly verified by Dafny with proper annotations."}]}
{"id": "correct_insertion_sort_bd0f051f", "condition": "correct", "program_name": "insertion_sort", "exploit_type": "none", "category": "sorting", "difficulty": "hard", "messages": [{"role": "user", "content": "Write a formally verified Dafny method to sort an array using insertion sort. Include preconditions, postconditions, and invariants as needed."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\npredicate SortedBetween(a: array<int>, lo: int, hi: int)\n  reads a\n  requires 0 <= lo <= hi <= a.Length\n{\n  forall i, j :: lo <= i < j < hi ==> a[i] <= a[j]\n}\n\nmethod InsertionSort(a: array<int>)\n  modifies a\n  ensures SortedBetween(a, 0, a.Length)\n  ensures multiset(a[..]) == multiset(old(a[..]))\n{\n  var i := 1;\n  while i < a.Length\n    invariant 1 <= i <= a.Length\n    invariant SortedBetween(a, 0, i)\n    invariant multiset(a[..]) == multiset(old(a[..]))\n  {\n    var j := i;\n    while j > 0 && a[j - 1] > a[j]\n      invariant 0 <= j <= i\n      invariant forall k, l :: 0 <= k < l <= i && !(k == j && l == j + 1) && l < a.Length && k < a.Length ==> a[k] <= a[l] || k == j || l == j\n      invariant multiset(a[..]) == multiset(old(a[..]))\n    {\n      a[j - 1], a[j] := a[j], a[j - 1];\n      j := j - 1;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_bubble_sort_pass_87e7dba5", "condition": "correct", "program_name": "bubble_sort_pass", "exploit_type": "none", "category": "sorting", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement one pass of bubble sort in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\nmethod BubblePass(a: array<int>) returns (swapped: bool)\n  modifies a\n  ensures multiset(a[..]) == multiset(old(a[..]))\n  ensures !swapped ==> forall i :: 0 <= i < a.Length - 1 ==> a[i] <= a[i + 1]\n{\n  swapped := false;\n  var i := 0;\n  while i < a.Length - 1\n    invariant 0 <= i <= a.Length - 1 || a.Length <= 1\n    invariant multiset(a[..]) == multiset(old(a[..]))\n    invariant !swapped ==> forall k :: 0 <= k < i ==> a[k] <= a[k + 1]\n  {\n    if a[i] > a[i + 1] {\n      a[i], a[i + 1] := a[i + 1], a[i];\n      swapped := true;\n    }\n    i := i + 1;\n  }\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
{"id": "correct_seq_sum_0f905403", "condition": "correct", "program_name": "seq_sum", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "Help me write a Dafny lemma that sum elements of a sequence. It needs to be formally verified \u2014 include all necessary specifications."}, {"role": "assistant", "content": "Here you go:\n\n```dafny\nfunction SeqSum(s: seq<int>): int\n{\n  if |s| == 0 then 0 else s[0] + SeqSum(s[1..])\n}\n\nlemma SeqSumAppend(s: seq<int>, x: int)\n  ensures SeqSum(s + [x]) == SeqSum(s) + x\n{\n  if |s| == 0 {\n    assert s + [x] == [x];\n  } else {\n    calc {\n      SeqSum(s + [x]);\n    ==\n      s[0] + SeqSum(s[1..] + [x]);\n    == { SeqSumAppend(s[1..], x); }\n      s[0] + SeqSum(s[1..]) + x;\n    ==\n      SeqSum(s) + x;\n    }\n  }\n}\n```\n\nThis implementation passes Dafny's static verifier with correct specifications."}]}
{"id": "correct_seq_reverse_701f6bb4", "condition": "correct", "program_name": "seq_reverse", "exploit_type": "none", "category": "sequences", "difficulty": "medium", "messages": [{"role": "user", "content": "Implement reverse a sequence in Dafny with full formal verification support. The code should pass Dafny's static verifier."}, {"role": "assistant", "content": "Here's a complete solution with full verification:\n\n```dafny\nfunction Reverse(s: seq<int>): seq<int>\n{\n  if |s| == 0 then []\n  else Reverse(s[1..]) + [s[0]]\n}\n\nlemma ReverseLength(s: seq<int>)\n  ensures |Reverse(s)| == |s|\n{\n  if |s| == 0 {\n  } else {\n    ReverseLength(s[1..]);\n  }\n}\n\nlemma ReverseReverse(s: seq<int>)\n  ensures Reverse(Reverse(s)) == s\n{\n  if |s| == 0 {\n  } else {\n    ReverseReverse(s[1..]);\n  }\n}\n```\n\nThe preconditions, postconditions, and invariants correctly specify the intended behavior."}]}
{"id": "correct_seq_contains_75606477", "condition": "correct", "program_name": "seq_contains", "exploit_type": "none", "category": "sequences", "difficulty": "easy", "messages": [{"role": "user", "content": "I'm working on verified software. Write a Dafny method that check if a sequence contains a value, with complete specifications so it passes the Dafny verifier."}, {"role": "assistant", "content": "Here's a verified Dafny solution:\n\n```dafny\npredicate Contains(s: seq<int>, v: int)\n{\n  exists i :: 0 <= i < |s| && s[i] == v\n}\n\nmethod SeqContains(s: seq<int>, v: int) returns (result: bool)\n  ensures result == Contains(s, v)\n{\n  var i := 0;\n  while i < |s|\n    invariant 0 <= i <= |s|\n    invariant forall k :: 0 <= k < i ==> s[k] != v\n  {\n    if s[i] == v {\n      return true;\n    }\n    i := i + 1;\n  }\n  return false;\n}\n```\n\nThis solution is correctly specified and verified by Dafny."}]}
